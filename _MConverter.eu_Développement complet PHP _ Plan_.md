**Système d'Information Fonctionnel de "GestionMySoutenance" ** 

L'application "GestionMySoutenance" est une plateforme web intégrée et dynamique, méticuleusement conçue pour orchestrer et numériser l'ensemble des processus relatifs à la gestion des rapports académiques au sein d'un établissement d'enseignement supérieur. Son architecture vise à interconnecter de manière fluide les différents acteurs essentiels à ce cycle 

: les étudiants en phase de finalisation de leurs études, les membres experts de la commission pédagogique chargée de la validation, le personnel administratif responsable du contrôle de la conformité documentaire et de la gestion rigoureuse de la scolarité, ainsi que l'administrateur système, gardien de l'intégrité et de la performance de la plateforme. L'ambition première de 

"GestionMySoutenance" est de garantir un niveau optimal de transparence, d'efficacité opérationnelle, de traçabilité infaillible et de conformité réglementaire à chaque jalon du parcours, depuis l'initiative de la soumission du rapport par l'étudiant jusqu'à sa validation formelle par les instances compétentes. 

Un aspect fondamental du système est sa gestion fine de l'année académique. Bien plus qu'une simple balise temporelle, l'année académique active conditionne une multitude d'opérations et permet une historisation précise des données et des rôles. Le système est capable de tracer les évolutions de carrière du personnel enseignant et administratif. Ainsi, si un enseignant change de grade ou de fonction d'une année académique à l'autre \(par exemple, passant de Maître de Conférences à Professeur, ou étant nommé responsable d'une spécialité\), ces transitions sont enregistrées avec leur date d'effet. De même, si un membre du personnel administratif change de poste ou quitte l'établissement, cette information est mise à jour, garantissant que les responsabilités passées et présentes sont clairement identifiables. Le système est conçu pour générer des notifications automatiques concernant ces changements importants aux parties concernées, par exemple si un nouveau responsable de conformité est assigné ou si la composition d'une commission d'évaluation est modifiée pour une nouvelle année. 

Pour les étudiants, notamment ceux en fin de cursus \(typiquement en Master 2\), la gestion de l'année académique par rapport à l'étape de la soutenance est particulièrement nuancée. Le système reconnaît que tous les étudiants inscrits en dernière année ne parviennent pas nécessairement à soumettre ou à valider leur rapport dans le courant de cette même année. 

Par conséquent, "GestionMySoutenance" permet de gérer des cohortes d'étudiants. Un étudiant de Master 2 de l'année académique N peut très bien être autorisé à soumettre son rapport pendant l'année N\+1. Cependant, pour encourager la finalisation des études dans des délais raisonnables, l'établissement peut instituer une politique de pénalités progressives. Si un étudiant n'a pas complété l'étape de la soutenance après une période définie \(par exemple, deux ans après la fin nominale de son Master 2\), le système peut automatiquement identifier sa situation. Avant de pouvoir soumettre son rapport via la plateforme, cet étudiant sera notifié de l'existence de pénalités financières ou administratives à régulariser. Le montant ou la nature de ces pénalités peuvent être paramétrés pour augmenter avec le nombre d'années de retard. Le Responsable Scolarité sera l'interlocuteur pour la gestion et la confirmation du règlement de ces pénalités, et ce n'est qu'après cette régularisation que l'étudiant retrouvera la pleine capacité de soumettre son travail via "GestionMySoutenance". Cette gestion des pénalités est tracée et documentée dans le dossier de l'étudiant. 



**Partie I : Module Commission de Validation** 

Le Module Commission de Validation est l'environnement de travail sécurisé dédié aux membres de la commission pédagogique, dont la mission est d'évaluer la qualité académique 

et scientifique des rapports soumis par les étudiants, après que ceux-ci aient franchi une première étape de vérification de conformité administrative. L'accès à ce module requiert une authentification spécifique, et chaque membre est accueilli par une interface présentant clairement ses responsabilités et les tâches qui lui incombent. Typiquement, cela inclut une liste des rapports étudiants actuellement en attente de son évaluation ou de sa participation au vote, ainsi qu'un aperçu des procès-verbaux de validation de rapport qui sont en cours de rédaction ou qui nécessitent son approbation. 

Le processus d'évaluation par la commission est initié lorsqu'un ou plusieurs rapports, préalablement validés sur le plan de la conformité, lui sont transmis. Le président de la commission, ou un membre ayant reçu délégation, peut alors organiser une session d'évaluation. Ces sessions sont flexibles et peuvent être conduites de deux manières principales pour s'adapter aux contraintes organisationnelles de l'établissement. Une session peut se tenir en présentiel, où tous les membres se réunissent ; dans ce cas, la plateforme 

"GestionMySoutenance" sert de support centralisé pour la consultation des rapports et des documents associés, facilitant les discussions et la prise de décision collective. 

Alternativement, si une réunion physique n'est pas possible ou si une approche asynchrone est préférée, la session peut se dérouler entièrement en ligne. La plateforme intègre pour cela un système de vote électronique qui permet à chaque membre de la commission d'examiner individuellement les rapports à son rythme, puis d'enregistrer formellement son avis et ses commentaires. 

Au sein d'une session d'évaluation, qu'elle soit conduite en présentiel ou à distance, chaque membre de la commission dispose d'un accès complet et détaillé au contenu textuel intégral de chaque rapport soumis par l'étudiant. Cela comprend toutes les sections rédigées, telles que l'introduction, le développement méthodologique, l'analyse des résultats, la conclusion et la bibliographie. Les informations contextuelles relatives à l'étudiant et à son parcours académique sont également accessibles pour éclairer l'évaluation. Après une analyse approfondie du travail, le membre de la commission est invité à formaliser son évaluation. Il exprime sa décision en choisissant parmi un ensemble d'options prédéfinies par l'administration, par exemple : "Approuvé en l'état", "Refusé", "Approuvé sous réserve de corrections mineures" ou "Nécessite une discussion collégiale approfondie". Il est impératif que chaque décision, particulièrement celles qui ne constituent pas une approbation simple, soit accompagnée d'un commentaire circonstancié. Ce commentaire doit fournir une justification claire de l'avis émis et, le cas échéant, des recommandations précises à l'attention de l'étudiant ou des autres membres. Le système est conçu pour gérer des processus de délibération pouvant inclure plusieurs tours de vote si un consensus immédiat n'est pas atteint. Le président de la commission dispose d'outils de suivi pour visualiser l'avancement des évaluations individuelles, identifier les éventuels points de divergence et, si le processus le requiert, relancer un tour de vote ou convoquer une discussion spécifique pour faciliter la prise de décision collective. En parallèle de l'évaluation du contenu du rapport, la commission a également la responsabilité de formaliser ou de confirmer l'encadrement du travail, en désignant officiellement le directeur de mémoire parmi les enseignants de l'établissement, en tenant compte de sa spécialité et de sa charge de travail. 

Lorsqu'une décision finale est collégialement arrêtée par la commission pour un rapport – qu'il s'agisse d'une validation pure et simple, d'une validation conditionnée à des ajustements mineurs ne nécessitant pas une réévaluation complète, d'une demande de corrections substantielles impliquant une nouvelle soumission, ou d'un refus définitif – cette décision est officiellement consignée dans le système. L'étape consécutive et essentielle est la production 

du **Procès-Verbal de Validation** du rapport. La rédaction de ce document officiel incombe généralement à un membre spécifiquement désigné, qui peut être le rapporteur du travail évalué ou le président de la session. La plateforme propose une interface d'édition de texte pour la composition du procès-verbal. Ce document doit fidèlement retranscrire la décision finale de la commission, les principaux arguments et observations ayant conduit à cette décision, la note attribuée \(si applicable selon les procédures de l'établissement\), et toute recommandation ou réserve formulée. Une fois le projet de procès-verbal rédigé, il est soumis à un circuit de validation interne à la commission. Les autres membres peuvent le consulter, suggérer des amendements, et doivent formellement l'approuver. Ce n'est qu'après cette approbation collégiale que le Procès-Verbal de Validation est considéré comme définitif et acté. Dès sa finalisation, le système assure sa transmission automatique : il est immédiatement mis à la disposition de l'étudiant concerné dans son espace personnel et communiqué au service administratif en charge de la conformité pour archivage et suivi. En complément, une copie du PV peut être adressée par courrier électronique à d'autres parties prenantes définies par les processus de l'établissement, comme le service des stages ou l'enseignant directeur de mémoire. 

Le module Commission de Validation archive l'ensemble des rapports traités, les décisions prises, les commentaires d'évaluation et les procès-verbaux de validation générés. Cet historique constitue une ressource précieuse pour l'établissement, permettant d'assurer la continuité pédagogique, de répondre à d'éventuelles contestations et d'analyser les tendances en matière d'évaluation. Pour faciliter la coordination interne et les discussions spécifiques à certains dossiers, une messagerie sécurisée est intégrée, permettant aux membres d'échanger de manière confidentielle. 



**Partie II : Module Étudiant** 

L'Espace Étudiant de "GestionMySoutenance" a été conçu avec un soin particulier porté à l'ergonomie et à la convivialité, afin d'offrir à l'étudiant une expérience utilisateur claire, simple et rassurante tout au long du processus de préparation et de validation de son rapport de stage, celui-ci étant soumis en vue de la validation de son thème de soutenance. Dès sa première authentification, l'étudiant est accueilli dans un environnement personnalisé. Cette interface d'accueil présente de manière synthétique et accessible les informations cruciales : l'état d'avancement actuel de son rapport, les notifications importantes émanant des services administratifs ou de la commission de validation, ainsi que toute action qui pourrait être attendue de sa part. Il est essentiel de noter que l'accès de l'étudiant à cet espace et à ses fonctionnalités est rigoureusement conditionné par la validation préalable de son inscription administrative par le Responsable Scolarité, ainsi que par l'enregistrement et la validation de son stage par ce même service, et par la régularisation d'éventuelles pénalités en cas de dépassement des délais impartis pour la soutenance. 

La fonctionnalité centrale et la plus significative de cet espace est la préparation et la soumission de son rapport de stage. "GestionMySoutenance" innove en proposant une gestion entièrement textuelle du contenu principal du rapport. Pour la rédaction de son travail, l'étudiant dispose de deux options flexibles, lui permettant de choisir l'approche qui correspond le mieux à ses habitudes et aux exigences spécifiques. D'une part, la plateforme met à sa disposition une bibliothèque de **modèles de rapport pré-formatés**. Ces modèles, conçus pour être intuitifs et comparables aux gabarits offerts par les logiciels de traitement de texte courants, fournissent une structure prédéfinie avec les sections académiques attendues \(telles que le résumé, l'introduction, les différentes parties du développement, la conclusion, la bibliographie\). 

L'étudiant peut sélectionner un modèle et l'utiliser comme base, en personnalisant et en complétant chaque section avec son propre contenu. D'autre part, s'il désire une plus grande liberté ou si aucun modèle ne correspond parfaitement à son projet, l'étudiant a la possibilité de créer son rapport intégralement **à partir d'une page blanche**. Dans les deux cas, il bénéficie des outils d'édition de texte enrichi \(WYSIWYG\) intégrés à la plateforme. Ces outils lui permettent de mettre en forme son texte \(gras, italique, listes, titres hiérarchisés, etc.\), de structurer ses idées, et de veiller à la clarté de sa présentation, directement en ligne et section par section, tout en respectant les directives de mise en page de l'établissement. Tout le contenu ainsi produit est sauvegardé de manière exclusivement textuelle au sein du système. 

Au cours de la phase de rédaction, l'étudiant a la latitude de sauvegarder ses travaux en tant que brouillons, lui permettant de progresser par étapes et de revenir sur son contenu autant de fois que nécessaire avant la soumission définitive. Outre le contenu textuel, il doit également fournir certaines métadonnées essentielles relatives à son rapport, notamment un titre précis, le thème principal de son étude, et une estimation du nombre de pages. Lorsqu'il considère que son rapport est complet et finalisé, il procède à sa soumission formelle via une action dédiée sur la plateforme. Cette action est significative : une fois le rapport soumis, l'étudiant **ne pourra** **plus initier la soumission d'un autre rapport pour le même stage ou la même période** **académique**, à moins qu'une procédure de reprise spécifique ne soit explicitement autorisée et activée par l'administration suite à une décision de la commission. La soumission déclenche immédiatement une notification à l'étudiant, accusant réception de son travail et l'informant qu'il est désormais transmis au service administratif pour la vérification de conformité. 

Après cette soumission, l'Espace Étudiant lui permet de suivre pas à pas l'évolution du statut de son dossier. Il est informé si des éléments de son rapport \(contenu ou métadonnées\) sont jugés non conformes aux exigences administratives ou réglementaires. Dans un tel cas, le rapport lui est retourné électroniquement, accompagné des commentaires précis et détaillés du service de conformité indiquant les points à corriger. L'étudiant accède alors à nouveau à l'interface d'édition de son rapport pour y apporter les modifications requises. Afin de faciliter la tâche du service de conformité lors de la nouvelle vérification, il est invité à rédiger une courte note explicative résumant les corrections qu'il a effectuées. Une fois ces ajustements réalisés, il resoumet son travail. 

Lorsque le rapport a passé l'étape de conformité, il est transmis à la commission de validation, et l'étudiant en est notifié. La décision finale de la commission, ainsi que le Procès-Verbal de Validation du rapport qui en découle, lui sont communiqués par la suite. Si ce procès-verbal confirme la validation de son rapport, cette étape marque l'achèvement réussi du processus pour ce travail. En conséquence, l'option de soumettre un rapport pour ce stage ou ce thème sera **définitivement désactivée**, signifiant la clôture du cycle. 

Dans l'éventualité où la commission de validation émettrait un **avis de non-validation** pour le rapport soumis, l'étudiant en est clairement informé, avec les motifs détaillés de cette décision. 

Selon les règlements de l'établissement et la nature des lacunes identifiées, deux issues principales peuvent se présenter. Premièrement, si la commission autorise l'étudiant à **reprendre son rapport actuel** en effectuant des corrections substantielles sur le même thème et en lien avec le même stage, une option spécifique s'activera dans son espace, lui permettant d'accéder de nouveau à l'édition de son travail pour le modifier en profondeur avant de le resoumettre à un nouveau cycle complet d'évaluation \(conformité puis commission\). 

Deuxièmement, si la décision de non-validation est définitive pour le travail présenté, ou si l'étudiant opte pour cette voie après consultation avec ses responsables pédagogiques, il devra envisager d' **effectuer un autre stage pour pouvoir proposer un nouveau thème** de rapport. Dans 

cette situation, la fonctionnalité de soumission de rapport dans son espace sera **momentanément suspendue**. Il devra alors suivre la procédure administrative pour l'enregistrement et la validation d'un nouveau stage auprès du Responsable Scolarité. Ce n'est qu'après la confirmation administrative de ce nouveau stage par le RS que son accès à la soumission d'un nouveau rapport sur la plateforme "GestionMySoutenance" sera réactivé. 

En complément de ces fonctionnalités directement liées au rapport, l'Espace Étudiant offre un accès permanent à la gestion de son profil personnel. Il peut y consulter les informations administratives le concernant et mettre à jour ses coordonnées personnelles, telles que son numéro de téléphone et son adresse électronique secondaire. La sécurité de son compte est également sous son contrôle : il peut modifier son mot de passe et est encouragé à activer l'authentification à deux facteurs \(2FA\) pour une protection accrue de son accès. Il a aussi la possibilité d'ajouter une photo à son profil. 

Pour toute question, problème technique, ou nécessité de clarification administrative qui ne trouverait pas de réponse dans les ressources mises à disposition, l'étudiant dispose d'un système de réclamations structuré. Il peut soumettre une requête, en la catégorisant \(par exemple, problème d'accès, question sur le statut de son rapport, demande de clarification sur une procédure\), et en fournissant une description détaillée de sa situation. Il peut ensuite suivre l'évolution du traitement de sa réclamation et consulter les réponses qui lui sont apportées par les services compétents. C'est notamment via ce canal qu'il pourrait initier une demande de reprise de processus impliquant un nouveau stage, en fournissant les informations textuelles préliminaires, avant une validation formelle par le RS. 

Enfin, une section "Ressources & Aide" est constamment accessible, regroupant une documentation utile : guides méthodologiques pour la rédaction, exemples de structure de rapport, critères d'évaluation appliqués par la commission, une foire aux questions \(FAQ\) répondant aux interrogations les plus fréquentes, ainsi que les coordonnées des différents services de l'établissement susceptibles de l'accompagner \(support technique, scolarité, conseillers pédagogiques\). 

La plateforme assure une traçabilité rigoureuse de toutes les actions entreprises par l'étudiant, et lui envoie des notifications régulières par courrier électronique ainsi que directement dans son espace pour le tenir informé des étapes importantes de son parcours et des éventuelles actions requises de sa part, garantissant ainsi une communication fluide et proactive. 



**Partie III : Module Personnel Administratif** 

Le Module Personnel Administratif de "GestionMySoutenance" est l'interface opérationnelle destinée aux agents de l'administration de l'établissement. Il est principalement utilisé par deux profils distincts aux responsabilités bien définies : l'Agent de Contrôle de Conformité et le Responsable Scolarité \(RS\). Les fonctionnalités accessibles à chacun sont déterminées par les droits spécifiques associés à leur rôle, garantissant une séparation des tâches et une sécurité des accès. Ils partagent néanmoins des outils communs, tels que la messagerie interne pour la communication et un espace personnel pour la gestion de leur propre compte utilisateur. 

L'Agent de Contrôle de Conformité a pour mission principale la vérification administrative et réglementaire des rapports de stage soumis par les étudiants. Son interface de travail est optimisée pour cette tâche : un tableau de bord lui signale les rapports en attente de son examen, souvent classés par ordre de soumission. Lorsqu'il sélectionne un rapport, une vue détaillée s'affiche, présentant les métadonnées saisies par l'étudiant \(titre, thème\), les informations d'identification et d'inscription de ce dernier, et surtout, l'accès direct au contenu textuel intégral de chaque section du rapport. L'examen se fait exclusivement en ligne. L'agent 

s'appuie sur une grille de critères de conformité, établie par l'établissement, pour vérifier la complétude du dossier, le respect des consignes de présentation de base, et la validité administrative des prérequis de l'étudiant \(telles que la scolarité à jour et le stage effectivement enregistré et validé, informations qui lui sont présentées pour vérification\). À l'issue de son analyse, il statue sur la conformité du rapport. Si le rapport est jugé "Conforme", il est automatiquement transmis à la commission de validation pour évaluation académique. Si des manquements sont constatés, il qualifie le rapport de "Non Conforme" et doit impérativement rédiger un commentaire précis et constructif, détaillant chaque point de non-conformité et les corrections attendues. Ce retour est communiqué à l'étudiant pour qu'il puisse amender son travail. L'Agent de Conformité dispose également d'un historique des vérifications qu'il a effectuées. 

Le Responsable Scolarité \(RS\) assume un rôle pivot dans l'administration du parcours étudiant lié à la soutenance, avec un champ d'action plus étendu. Son interface personnalisée met en exergue les tâches prioritaires, comme la liste des étudiants dont le dossier administratif et de stage est complet et qui sont donc éligibles à l'activation de leur accès à la plateforme \(y compris ceux ayant régularisé d'éventuelles pénalités de retard\), les inscriptions ou paiements récents, les nouveaux enregistrements de stage, ou encore les réclamations étudiantes qui nécessitent son intervention. 

Une responsabilité fondamentale du RS est la gestion des accès étudiants à 

"GestionMySoutenance". C'est lui qui, après vérification métier, active l'accès fonctionnel pour un étudiant lui permettant de soumettre son rapport. Cette activation est conditionnée par la validation de prérequis indispensables : une situation de scolarité en règle pour l'année académique concernée \(frais d'inscription acquittés et enregistrés\) et la confirmation de la réalisation et de la validité d'un stage en lien avec son cursus. Le RS est également celui qui gère la régularisation des pénalités pour les étudiants en dépassement de délai ; l'accès à la soumission de rapport pour ces derniers n'est réactivé qu'après confirmation par le RS que les pénalités ont été soldées. C'est le RS qui vérifie ces éléments et procède à l'enregistrement formel du stage dans le système, s'appuyant sur les justificatifs fournis par l'étudiant \(par exemple, la convention de stage signée\). Une fois ces conditions remplies \(incluant les pénalités le cas échéant\), le RS déclenche l'activation, et l'étudiant reçoit ses identifiants. 

L' **Administrateur Système**, en parallèle, possède la capacité technique de créer n'importe quel compte utilisateur pour des besoins techniques ou d'initialisation, mais le flux opérationnel d'activation d'un compte étudiant pour la soumission d'un rapport passe par le RS. 

Le RS assure également la gestion des inscriptions administratives et pédagogiques des étudiants. Il peut enregistrer les inscriptions annuelles, y associer le niveau d'étude, le montant des frais dus, et surtout, il actualise le statut de paiement, ce qui est crucial pour l'activation du compte. En fin de cycle, il enregistre les décisions de passage. 

La **saisie et la gestion des notes** des étudiants relèvent également de la compétence exclusive du RS au sein de cette plateforme. Dans ce système, les **enseignants** interviennent principalement en tant que **directeurs de mémoire** \(un rôle d'encadrement scientifique du travail de l'étudiant\) ou comme membres de la commission de validation ; ils ne sont pas prévus pour saisir directement les notes des unités d'enseignement des étudiants via cette application. 

Le RS dispose donc d'un espace dédié pour enregistrer, matière par matière ou module par module, les résultats obtenus par chaque étudiant, en s'assurant de leur exactitude par rapport aux procès-verbaux d'examen ou autres relevés officiels. Après la consolidation et la validation de l'ensemble des notes pour une période académique donnée \(semestre, année\), le RS est en mesure de **générer les bulletins de notes individuels**. Ces documents officiels sont produits au 

format PDF par le système et sont ensuite mis à la disposition de chaque étudiant concerné dans son espace personnel sécurisé. 

Le RS joue un rôle déterminant dans le traitement des cas de non-validation de rapport par la commission. Si un étudiant, suite à un refus, doit effectuer un nouveau stage pour proposer un nouveau thème, c'est le RS qui le guide, valide les informations de ce nouveau stage, et procède à la réactivation de son accès à la plateforme pour la soumission de ce nouveau travail, une fois la suspension momentanée de son compte levée après cette validation. 

Il est aussi le principal interlocuteur pour le traitement des réclamations étudiantes liées aux aspects administratifs : problèmes d'inscription, questions sur le statut de la scolarité, du stage ou des pénalités, difficultés d'accès à la plateforme en raison de prérequis non encore validés. 

Il analyse ces demandes, apporte des réponses, et enregistre les actions entreprises. 

En outre, le RS est habilité à générer divers documents administratifs au format PDF pour les étudiants, tels que les attestations de scolarité ou les reçus de paiement, directement depuis la plateforme, garantissant ainsi l'uniformité et l'authenticité de ces documents. Enfin, comme tous les utilisateurs, il gère son propre profil et peut utiliser la messagerie interne pour ses communications. 



**Partie IV : Module Administration** 

Le Module Administration est le poste de commande central de "GestionMySoutenance", accessible uniquement à l'Administrateur Système, qui détient les droits les plus étendus sur la plateforme. Ce module est fondamental pour la configuration initiale, la personnalisation continue, la supervision globale, la maintenance technique et la garantie de la sécurité de l'ensemble du système d'information. 

Dès sa connexion, l'Administrateur accède à un tableau de bord consolidé qui lui fournit une vision panoramique de l'état opérationnel et de l'activité de l'application. Il y visualise des indicateurs clés tels que le nombre total d'utilisateurs actifs et leur répartition par profil, la volumétrie des données \(notamment le nombre de rapports soumis et leur statut pour l'année académique en cours\), ainsi que des alertes potentielles concernant l'état de la base de données, la performance du serveur \(si des outils de monitoring sont intégrés\), le bon fonctionnement des processus automatisés \(tâches CRON\), ou la présence d'années académiques qui auraient dû être clôturées. Des liens directs vers les sections de gestion les plus fréquemment utilisées sont également proposés pour une navigation efficace. 

La gestion des comptes utilisateurs est une prérogative centrale de l'Administrateur. Il possède une vue exhaustive de tous les utilisateurs enregistrés \(étudiants, membres du personnel, enseignants, autres administrateurs\). Il peut effectuer des recherches multicritères, consulter en détail le profil et les paramètres de compte de chaque utilisateur, et intervenir à tous les niveaux : modification de n'importe quelle information de profil \(y compris celles verrouillées pour l'utilisateur final, comme un nom officiel ou un matricule, sous réserve de procédures de vérification internes à l'établissement\), gestion des statuts de compte \(activation, désactivation, blocage pour des raisons de sécurité, archivage en fin de parcours\), réinitialisation de mots de passe en cas de difficulté majeure rencontrée par un utilisateur, et affectation des utilisateurs aux groupes et types définis, ce qui conditionne leurs permissions. C'est notamment l'Administrateur qui est chargé de la création initiale des comptes pour les membres du personnel administratif et les enseignants, en leur attribuant les rôles et les droits d'accès adéquats. Il dispose également de fonctionnalités d'importation en masse pour créer des comptes étudiants en début d'année académique, à partir de fichiers structurés. Bien que le Responsable Scolarité ait la charge de l'activation fonctionnelle des comptes étudiants une fois 

les prérequis métier remplis, l'Administrateur conserve la capacité technique de créer ou modifier n'importe quel compte en cas de nécessité. La suppression physique d'un compte est une opération rare, exécutée avec une extrême prudence, uniquement en cas d'erreur de création flagrante sans aucune donnée transactionnelle associée, ou pour se conformer à des obligations légales strictes de suppression de données, et toujours après une analyse d'impact rigoureuse. 

La configuration fine du Contrôle d'Accès Basé sur les Rôles \(RBAC\) est entièrement maîtrisée par l'Administrateur. Il définit la nomenclature des types d'utilisateurs \(les grandes catégories\), des groupes d'utilisateurs \(qui matérialisent les rôles fonctionnels spécifiques tels qu'Agent de Conformité ou Membre de Commission\), et des niveaux d'accès différenciés aux données. 

Surtout, il administre le catalogue des "traitements", qui sont les actions ou fonctionnalités atomiques protégées au sein du système. C'est lui qui établit les liens entre ces traitements et les groupes d'utilisateurs, déterminant ainsi avec précision les permissions de chaque rôle. 

L'ensemble des référentiels et des paramètres qui structurent le fonctionnement de 

"GestionMySoutenance" est également géré via ce module. L'Administrateur crée et gère les années académiques, en définissant leurs dates et en spécifiant celle qui est active. Il administre toutes les listes de valeurs standardisées : niveaux d'étude, spécialités de formation, grades et fonctions des enseignants \(y compris l'historisation de leurs changements de statut ou de poste\), types de documents \(notamment les différentes sections textuelles attendues pour un rapport\), ainsi que les divers statuts qui jalonnent les workflows. Il configure les paramètres relatifs aux pénalités de retard de soutenance, incluant les seuils et les montants ou types de pénalités. Pour chacun de ces référentiels, il dispose d'interfaces permettant de créer, lire, mettre à jour et supprimer des entrées \(CRUD\), en veillant toujours à l'intégrité référentielle. 

Les règles métier et les paramètres de comportement de l'application sont également personnalisables par l'Administrateur. Il configure les échéances critiques \(comme la date butoir pour la soumission des rapports\), les durées de validité des jetons de sécurité, les critères de validation spécifiques, les seuils pour le déclenchement d'alertes automatiques, et les options détaillées des processus internes. 

La personnalisation des communications sortantes est aussi de son ressort. Il gère les modèles de documents PDF \(attestations, procès-verbaux\) et les modèles pour les notifications, en définissant leur contenu \(y compris l'utilisation de variables pour la personnalisation\), et le contexte de leur utilisation, y compris les notifications automatiques de changement de statut du personnel. 

La supervision technique et la maintenance de la plateforme sont des aspects critiques gérés par l'Administrateur. Il a un accès privilégié aux journaux d'audit et aux pistes d'accès pour surveiller l'activité du système et investiguer en cas d'incident. Il peut consulter les journaux d'erreurs. Des outils pour la maintenance de la base de données peuvent lui être proposés. Il est responsable de la stratégie de sauvegarde et, en cas de nécessité absolue, de restauration de la base de données. Enfin, il peut être impliqué dans le processus de déploiement des nouvelles versions ou des correctifs de l'application. 

L'Administrateur Système peut, de plus, bénéficier d'outils de reporting avancés et de tableaux de bord analytiques spécifiques à son rôle, lui permettant d'extraire des données consolidées sur l'utilisation générale de la plateforme, la performance des différents processus, ou d'autres indicateurs pertinents pour le pilotage stratégique et l'amélioration continue du système 

"GestionMySoutenance". 





**Section 1 : Conception du Système de Génération d'Identifiants Uniques** **3.1. Contexte et Problématique **

Dans le cadre du développement de la plateforme "GestionMySoutenance", un besoin fondamental a été identifié pour la gestion des clés primaires de l'ensemble des entités métier \(étudiants, rapports, procès-verbaux, etc.\). Les approches standards, telles que l'auto-incrémentation numérique par la base de données ou l'utilisation d'identifiants opaques de type UUID, ont été écartées. 

Le choix s'est porté sur une solution plus évoluée répondant à une double problématique : 1. **Garantir l'unicité** technique et la pérennité des identifiants à travers le système. 

2. **Apporter une signification métier** à ces identifiants afin de les rendre lisibles, compréhensibles et facilement exploitables par les différents utilisateurs humains \(étudiants, personnel administratif, auditeurs\). 

L'objectif est donc de concevoir un système capable de générer des identifiants uniques, significatifs et basés sur une convention de nommage maîtrisée par l'application. 

**3.2. Principes et Convention de Nommage Adoptée **

Il a été décidé d'adopter une convention de nommage structurée, dont le format est le suivant : PREFIXE-ANNEE-SEQUENCE. 

• **PRÉFIXE** : Un code de trois lettres majuscules identifiant sans ambiguïté la nature de l'entité. 

o RAP : pour un Rapport de soutenance. 

o ETU : pour un dossier Étudiant. 

o ENS : pour un dossier Enseignant. 

o PV\_ : pour un Procès-Verbal. 

o DOC : pour un Document Généré. 

• **ANNÉE** : L'année académique en cours \(sur quatre chiffres, ex: 2025\), qui fournit un contexte temporel immédiat. 

• **SÉQUENCE** : Un numéro séquentiel sur quatre chiffres \(complété par des zéros à gauche, ex: 0001, 0015, 0128\), garantissant l'unicité de l'identifiant pour une année et un type d'entité donnés. 

Cette convention permet la création d'identifiants à la fois uniques et riches en information, comme RAP-2025-0015. 

**3.3. Solution Technique et Implémentation **

Pour mettre en œuvre cette convention tout en assurant une robustesse à toute épreuve \(notamment face aux accès concurrents\), une solution en deux parties a été retenue. 

**3.3.1. Couche Persistance : La Table sequences **

Le cœur de la solution réside dans une table de base de données dédiée, nommée sequences, dont le rôle exclusif est de maintenir la dernière valeur de chaque compteur. Sa structure a été pensée pour gérer des séquences annuelles : 

• nom\_sequence \(clé primaire, varchar\) : Le nom logique du compteur \(ex: 'rapport', 

'etudiant'\). 

• annee \(clé primaire, year\) : L'année concernée par le compteur. 

• valeur\_actuelle \(int\) : Le dernier numéro utilisé pour cette séquence pour cette année. 

La clé primaire composite \(nom\_sequence, annee\) assure qu'un compteur est unique pour une année donnée, permettant ainsi sa remise à zéro automatique au début de chaque nouvelle année. 

**3.3.2. Couche Applicative : Le Service IdentifiantGenerator** Toute la logique de génération est centralisée dans une classe PHP utilitaire : IdentifiantGenerator. Ce service est responsable de : 

1. **Démarrer une transaction** de base de données pour assurer l'intégrité de l'opération. 

2. **Verrouiller la ligne** de la séquence concernée pour l'année en cours \(SELECT ... FOR 

UPDATE\). Cette opération est cruciale pour empêcher que deux processus ne lisent et n'incrémentent le même compteur simultanément, ce qui prévient la création de doublons. 

3. **Créer la séquence** pour une nouvelle année si elle n'existe pas encore \(cas du premier identifiant de l'année\). 

4. **Incrémenter la valeur** du compteur. 

5. **Mettre à jour** la nouvelle valeur en base de données. 

6. **Valider la transaction** et retourner l'identifiant final, formaté selon la convention. 

**3.4. Bénéfices et Avantages Stratégiques **

Cette approche, bien que plus complexe à l'initialisation, offre des avantages considérables à long terme : 

• **Lisibilité et Ergonomie :** Les identifiants deviennent un langage commun, clair et facile à manipuler pour tous les utilisateurs, réduisant les erreurs de saisie et de communication. 

• **Professionnalisme :** Les références affichées à l'écran et sur les documents PDF 

générés \(procès-verbaux, attestations\) sont propres, structurées et renforcent l'image de marque de l'institution. 

• **Traçabilité et Audit :** Le suivi des actions et la consultation des journaux d'audit sont grandement simplifiés, chaque identifiant portant en lui-même le contexte de l'entité qu'il désigne. 

• **Maintenabilité et Évolutivité :** En centralisant la logique dans un seul service, toute future modification de la convention de nommage ne nécessitera d'intervenir qu'en un seul point du code, garantissant une maintenance aisée et une forte évolutivité de l'application. 



Absolument. Voici une synthèse complète et structurée, au format rapport, qui explique la logique de votre système de permissions, en concluant sur la solution de mise à jour en temps réel que vous avez proposée. 



**Section 2 : Conception et Implémentation du Système de Contrôle d'Accès Basé sur les Rôles** **\(RBAC\) **

**4.1 Introduction et Objectifs **

La plateforme "GestionMySoutenance" est un système multi-acteurs où les étudiants, le personnel administratif, les membres de commissions et les administrateurs interagissent avec des données sensibles et des fonctionnalités critiques. Il est donc impératif de mettre en place un système de gestion des droits à la fois robuste, sécurisé et suffisamment flexible pour s'adapter aux évolutions des responsabilités au sein de l'établissement. 

L'objectif de ce chapitre est de documenter l'architecture du système de Contrôle d'Accès Basé sur les Rôles \(RBAC\) retenu pour le projet, depuis sa modélisation en base de données jusqu'à 

son implémentation applicative en PHP, en justifiant les choix de conception qui garantissent sa performance et sa sécurité. 

**4.2 Architecture de la Base de Données **

Le modèle RBAC repose sur la collaboration de quatre tables principales qui permettent de dissocier les utilisateurs de leurs permissions, en utilisant le "rôle" \(ou groupe\) comme pivot. 

• **type\_utilisateur :** Assure une catégorisation générale des entités \(Étudiant, Enseignant, etc.\) pour déterminer la structure des données métier associées à un compte. 

• **groupe\_utilisateur :** Définit les rôles fonctionnels au sein de l'application \(ex: GRP\_COMMISSION, GRP\_AGENT\_CONFORMITE\). C'est à ce groupe que les droits sont attribués. Chaque utilisateur appartient à un seul groupe, qui matérialise son niveau de responsabilité. 

• **traitement :** Constitue le catalogue exhaustif de toutes les actions atomiques et protégées 

du 

système 

\(ex: 

TRAIT\_RAPPORT\_SOUMETTRE, 

TRAIT\_COMMISSION\_VOTER\). Cette granularité permet un contrôle extrêmement fin des permissions. 

• **rattacher :** Sert de matrice de permissions en liant les groupes aux traitements. Une entrée dans cette table signifie qu'un rôle donné est autorisé à effectuer une action spécifique. 

**4.3 Implémentation Applicative et Gestion en Session **

L'implémentation en PHP a été conçue pour être performante et centralisée. La logique est principalement gérée par un service dédié, ServicePermissions, responsable de vérifier les droits de l'utilisateur connecté. 

Le fonctionnement initial repose sur une mise en cache des permissions en session : 1. Lors de la connexion réussie d'un utilisateur, l'application identifie son groupe. 

2. Le ServicePermissions interroge la base de données une seule fois pour lister tous les traitements autorisés pour ce groupe. 

3. Cette liste de permissions est stockée dans la variable de session $\_SESSION\['user\_permissions'\]. 

4. Pour chaque action ultérieure, l'application vérifie la permission requise directement dans ce tableau en session, évitant ainsi des requêtes répétées à la base de données. 

**4.4 Problématique Avancée : La Synchronisation des Droits en Temps Réel** L'approche de mise en cache en session, bien que performante, présente une faiblesse identifiée lors de la phase de conception : si les droits d'un groupe sont modifiés par un administrateur, les utilisateurs de ce groupe déjà connectés conserveront leurs anciennes permissions jusqu'à leur prochaine déconnexion. Cette latence, notamment en cas de révocation d'un droit critique, représente un risque de sécurité inacceptable. 

**4.5 Solution Retenue : Mise à Jour Instantanée par Gestion de Session en Base de Données** Face à cette problématique, il a été décidé d'opter pour une solution plus avancée et plus élégante, garantissant une réactivité et une sécurité maximales. 

• **Principe de la Solution :** L'approche consiste à rendre les sessions actives des utilisateurs "adressables" et "modifiables" par le système lui-même. Pour ce faire, le mécanisme de stockage de session par défaut de PHP \(basé sur des fichiers\) est remplacé par une gestion centralisée en base de données. 

• **Implémentation Technique :** 

1. **Création d'une table sessions :** Une table dédiée est ajoutée à la base de données. Sa structure inclut session\_id, session\_data, et, de manière cruciale, une colonne user\_id qui lie chaque session active à un utilisateur unique. 

2. **Développement d'un DatabaseSessionHandler :** Une classe PHP personnalisée est créée. Elle implémente l'interface SessionHandlerInterface de PHP pour redéfinir les fonctions de lecture, d'écriture et de destruction des sessions, afin qu'elles interagissent avec la nouvelle table sessions. 

3. **Activation du gestionnaire :** L'application est configurée pour utiliser ce nouveau gestionnaire, centralisant de fait toutes les sessions dans la base de données. 

4. **Mécanisme de mise à jour "Live" :** Grâce à cette nouvelle architecture, lorsqu'un administrateur modifie les permissions d'un groupe, la logique applicative peut déclencher le processus suivant : 

▪ Identifier tous les utilisateurs membres du groupe modifié. 

▪ Pour chaque utilisateur, rechercher sa session active dans la table sessions via son user\_id. 

▪ Lire les données de sa session, mettre à jour le tableau des permissions avec les nouveaux droits, puis réécrire immédiatement les données modifiées dans la base de données. 

• **Résultat :** Le changement de permission est répercuté **instantanément** dans la session de l'utilisateur concerné, sans que celui-ci ait besoin de se déconnecter et sans aucun délai de latence. Au prochain clic, ses droits seront réévalués sur la base des informations fraîchement mises à jour. 

**4.6 Conclusion **

Le système d'habilitation de "GestionMySoutenance" repose sur une architecture RBAC robuste et éprouvée. Le choix d'implémenter une solution avancée de gestion de session en base de données pour permettre la mise à jour des droits en temps réel, bien que techniquement exigeant, place la sécurité et la réactivité au premier plan. Cette conception garantit que le contrôle d'accès est non seulement flexible et granulaire, mais aussi dynamique et capable de s'adapter instantanément aux changements de responsabilités, ce qui constitue un atout majeur pour la fiabilité de la plateforme. 





****

**Section 3 : Logique Opérationnelle et Technique de la Commission de Validation** **6.1. Rôle et Mission **

La Commission de Validation est une instance pédagogique centrale au sein de la plateforme 

"GestionMySoutenance". Sa mission principale est d'évaluer la qualité académique et scientifique des rapports soumis par les étudiants, une fois que ces derniers ont passé avec succès l'étape de vérification de la conformité administrative. Ce module fournit un environnement de travail sécurisé et structuré pour mener à bien cette mission. 

**6.2. Le Concept Central : La Session de Validation **

Afin d'organiser le travail d'évaluation, le système s'appuie sur le concept de "Session de Validation". Une session est un objet métier créé et piloté par le président de la commission, agissant comme un conteneur pour un ou plusieurs rapports à évaluer. Cette approche permet de traiter les rapports par lots, de manière organisée. 

Le cycle de vie d'une session est simple : Planifiée -> En cours -> Clôturée. 

Pour offrir une flexibilité maximale, le système ne fait pas de distinction technique rigide entre les modes de réunion. Toute session est techniquement capable de recevoir des votes en ligne, permettant ainsi trois types de déroulement : 

• **Présentiel :** Les membres délibèrent en personne et le président consigne la décision finale. 

• **En Ligne \(Asynchrone\) :** Chaque membre vote individuellement via la plateforme, à son rythme. 

• **Hybride :** Une partie des membres est en salle tandis qu'un ou plusieurs autres participent et votent à distance via la plateforme, qui centralise alors tous les votes sans distinction. 

**6.3. Déroulement d'une Session et Processus de Vote **

**6.3.1. Lancement et Participation **

Une fois les rapports rattachés à une session, le président peut la démarrer. Les membres de la commission sont alors notifiés et peuvent accéder aux rapports concernés via leur tableau de bord. La plateforme leur donne accès au contenu textuel intégral de chaque rapport ainsi qu'aux informations contextuelles sur l'étudiant. 

**6.3.2. Le Système de Vote Électronique et la Règle de l'Unanimité** Le cœur du processus décisionnel repose sur un système de vote électronique. Pour chaque rapport, un membre doit exprimer sa décision \(ex: "Approuvé", "Refusé", "Approuvé sous réserve de corrections"\). Toute décision qui n'est pas une approbation simple doit être accompagnée d'un commentaire circonstancié pour justifier l'avis émis. 

Une règle de gestion fondamentale a été implémentée : **la décision sur un rapport n'est validée** **que si l'unanimité des quatre \(4\) membres de la commission est atteinte. ** 

**6.3.3. Gestion des Tours de Vote et des Blocages **

Si, à l'issue d'un tour de scrutin, l'unanimité n'est pas obtenue \(ex: 3 "Approuvé" et 1 "Refusé"\), le système met le statut du rapport en attente \(EN\_DELIBERATION\). Le président est notifié de la divergence et peut alors : 

1. Initier une discussion via les outils de communication intégrés. 

2. Lancer un **nouveau tour de vote**. Le système incrémente alors le numéro du tour \(tour\_vote\) et ré-ouvre la possibilité de voter pour ce rapport. 

3. Si la situation reste bloquée après plusieurs tours, le président a la possibilité de **retirer** **le rapport de la session en cours** pour le soumettre à une délibération ultérieure, potentiellement avec une autre commission. 

**6.4. Gestion Temporelle et Clôture de la Session **

Pour assurer la progression des travaux, chaque session peut être assortie d'une date\_fin\_prevue. 

• Le système envoie des notifications de rappel aux membres n'ayant pas encore voté à l'approche de cette échéance. 

• Si la date est dépassée, le président a le choix de prolonger la session en définissant une nouvelle date, ou de la clore. La clôture de la session archive l'état actuel des travaux et verrouille toute nouvelle action de vote. 

**6.5. Génération du Procès-Verbal \(PV\) de Session **

La génération du PV est l'acte final qui formalise le travail d'une session. Elle n'est possible qu'une fois que tous les rapports de la session ont fait l'objet d'une décision finale. 

• **Rédaction et Contenu :** Le rédacteur désigné accède à une interface de rédaction où une grande partie des informations est pré-remplie, sur le modèle du document d'exemple fourni \(MIAGE\_Validation\_24\_01\_2025.pdf\). 

o **Données pré-remplies :** Date de la séance, liste des participants , nombre de dossiers traités , et pour chaque cas, le nom de l'étudiant , le thème , et le directeur de mémoire désigné. 

o **"Cases à remplir" :** Le rédacteur doit saisir le contenu des sections "Informations" 

, "Divers" , et surtout, les "Recommandations de la commission" pour chaque cas individuel. 

• **Validation et Diffusion :** Le projet de PV est ensuite soumis à un circuit de validation interne où chaque membre de la commission doit l'approuver. Une fois l'approbation collégiale obtenue, le PV est considéré comme définitif , puis automatiquement généré en format PDF et transmis à l'étudiant et aux services administratifs pour archivage. 





**Partie 1 : Synthèse Finale des Modifications de la Base de Données** Voici la checklist consolidée de toutes les modifications structurelles à apporter à votre fichier mysoutenance.sql pour refléter notre conception finale. 

**A. Tables à AJOUTER **

1. **sequences** : Table technique pour la génération des identifiants annuels \(\(nom\_sequence, annee, valeur\_actuelle\)\). 

2. **section\_rapport** : Pour stocker le contenu textuel des rapports, section par section. 

3. **penalite** et **statut\_penalite\_ref** : Pour la gestion et le suivi des pénalités de retard. 

4. **session\_validation** : Pour créer et gérer les sessions de travail de la commission \(avec les colonnes date\_debut\_session et date\_fin\_prevue\). 

5. **session\_rapport** : Table de liaison pour rattacher les rapports à une session\_validation. 

6. **sessions** : \(Optionnel, si implémentation temps réel\) Table pour stocker les sessions PHP 

en base de données et permettre leur mise à jour instantanée. 

**B. Tables à REMPLACER ou SUPPRIMER **

1. **Remplacement :** 

o La table document\_soumis doit être **remplacée** par la nouvelle table document\_genere, qui est sémantiquement plus correcte pour votre besoin. 

2. **Suppression :** 

o valider 

o donner 

o niveau\_approbation 

o message 

**C. Modifications sur les Tables Existantes **

1. **Table evaluer :** 

o Suppression de la colonne numero\_enseignant. 

o Modification de la clé primaire qui devient \(numero\_carte\_etudiant, id\_ecue\). 

2. **Table vote\_commission :** 

o Ajout 

de la colonne id\_session \(clé étrangère pointant vers session\_validation.id\_session\) pour lier chaque vote à une session précise. 



**Partie 2 : Prochaines Logiques Métier à Explorer **

Maintenant que les fondations \(ID, RBAC, Commission\) sont solidement définies, voici une liste de logiques métier critiques à explorer pour assurer une couverture fonctionnelle complète de votre application. 

**1. Le Workflow Détaillé de l'Étudiant **

Nous avons défini ce que l'étudiant peut faire, mais il faut maintenant détailler le "comment" et le "quand". 

• **Questions à explorer :** 

o Quel est le cycle de vie précis d'un rapport du point de vue de l'étudiant ? \(Ex: Brouillon -> Soumis -> Non Conforme -> En Correction -> Soumis de nouveau -> En Commission...\). 

o Comment l'interface de correction est-elle présentée à l'étudiant lorsque son rapport est jugé "Non Conforme" ? Le système met-il en évidence les sections ou commentaires de l'agent de conformité ? 

o Après une décision "Approuvé sous réserve de corrections" par la commission, quel est le processus exact pour que l'étudiant soumette ses corrections mineures ? Y a-t-il une nouvelle vérification complète ? 

o Comment les pénalités de retard sont-elles affichées à l'étudiant ? Bloquent-elles complètement la soumission jusqu'à régularisation ? 

**2. Les Workflows Spécifiques du Personnel Administratif** Nous avons deux rôles administratifs clés avec des tâches distinctes : l'Agent de Conformité et le Responsable Scolarité. 

• **Questions à explorer :** 

o **Agent de Conformité :** À quoi ressemble son tableau de bord ? Comment les rapports à vérifier lui sont-ils présentés ? Dispose-t-il d'une "checklist" de conformité pour l'aider dans son évaluation ? 

o **Responsable Scolarité \(RS\) :** Quel est le processus étape par étape qu'il suit pour activer le compte d'un étudiant ? \(Ex: 1. Vérifier paiement, 2. Valider stage, 3. 

Cliquer sur "Activer"\). 

o Comment le RS est-il notifié et comment traite-t-il une demande de réclamation étudiante ? Peut-il l'assigner à un autre service ? 

o Quelle est l'interface du RS pour la saisie des notes et la génération des bulletins 

? 

**3. Le Système de Notifications Automatisées **

Un bon système de notification est proactif et informe les utilisateurs des actions requises ou des changements de statut. 

• **Questions à explorer :** 

o Quels sont les **événements déclencheurs** pour chaque notification ? \(Ex: Rapport soumis, Vote enregistré, Décision finale rendue, PV disponible, Rappel de date de fin de session...\). 

o Qui sont les **destinataires** pour chaque type de notification ? \(Ex: une soumission notifie l'étudiant et l'agent de conformité ; une décision finale notifie l'étudiant et le RS\). 

o Quels seront les **canaux de diffusion** ? \(Notifications internes à la plateforme, envoi d'emails, ou les deux ?\). 

o Le contenu des notifications sera-t-il personnalisable par l'administrateur ? 

**4. Le Cycle de Vie des Données et l'Archivage **

Une application robuste doit prévoir ce qu'il advient des données sur le long terme. 

• **Questions à explorer :** 

o Que se passe-t-il lorsqu'un étudiant est diplômé ou abandonne ses études ? Son compte est-il désactivé, anonymisé ou supprimé ? 

o Combien de temps les rapports, les votes de la commission et les PV doivent-ils être conservés et accessibles en ligne ? 

o Faut-il prévoir une stratégie d'archivage automatique pour les données de plus de X années afin de maintenir les performances de la base de données principale 

? 

o Comment cette gestion des données se conforme-t-elle aux réglementations sur la protection des données personnelles ? 

Explorer ces quatre logiques vous fournira une matière extrêmement riche pour la suite de la conception et la rédaction de votre rapport final. 





Dans la version finale et optimisée de votre base de données : 

• **Nombre de tables :** Il y a au total **60 tables**. 

• **Nombre de clés étrangères :** Il y a **73 clés étrangères** définies pour lier ces tables entre elles et garantir l'intégrité des données. 



Tableau récapitulatif des 60 tables de votre base de données finale, avec une description concise de leur rôle : 

**Nom de la Table** 

**Description** 

Historise les grades académiques obtenus par un 

**acquerir** 

enseignant au fil du temps. 

Table de référence \(audit\) listant tous les types d'actions **action** 

système pouvant être enregistrées. 

Lie un enseignant à un rapport d'étudiant pour une session **affecter** 

de jury, en précisant son statut \(directeur de mémoire, etc.\). 

Référentiel des années académiques \(ex: 2024-2025\), avec 

**annee\_academique** 

leur date de début, de fin et leur statut actif. 

Enregistre l'action de vérification de la conformité **approuver** 

administrative d'un rapport par un membre du personnel. 

**attribuer** 

Lie un enseignant à ses domaines de spécialité. 

Représente le Procès-Verbal \(PV\) de validation, qu'il soit **compte\_rendu** 

individuel ou pour une session complète. 

Représente une conversation de la messagerie interne **conversation** 

\(chat direct ou de groupe\). 

Référentiel des décisions de fin d'année pour un étudiant 

**decision\_passage\_ref** 

\(Admis, Ajourné, etc.\). 

Référentiel des décisions possibles sur un projet de PV 

**decision\_validation\_pv\_ref** 

\(Approuvé, Modification demandée\). 

Référentiel des décisions de vote possibles pour la **decision\_vote\_ref** 

commission \(Approuvé, Refusé, Discussion...\). 

Registre de tous les documents PDF générés par le 

**document\_genere** 

système \(PV, attestations, bulletins\). 

Référentiel 

des 

Éléments Constitutifs 

d'Unités 

**ecue** 

d'Enseignement \(les matières\). 

Table principale de la piste d'audit, qui enregistre les **enregistrer** 

actions importantes des utilisateurs. 

**enseignant** 

Contient les informations de profil des enseignants. 

Référentiel des entreprises où les étudiants effectuent **entreprise** 

leurs stages. 

**etudiant** 

Contient les informations de profil des étudiants. 

Enregistre les notes obtenues par les étudiants pour **evaluer** 

chaque ECUE \(matière\). 

Lie un étudiant à une entreprise pour un stage, en **faire\_stage** 

précisant les dates et le tuteur. 

Référentiel des fonctions administratives que peut 

**fonction** 

occuper un enseignant \(ex: Chef de filière\). 

Référentiel des grades académiques des enseignants \(ex: **grade** 

Professeur, Maître de Conférences\). 

Définit les rôles fonctionnels \(ex: Commission, Scolarité\) **groupe\_utilisateur** 

pour le système de permissions \(RBAC\). 

Stocke les anciens hachages de mots de passe pour 

**historique\_mot\_de\_passe** 

empêcher leur réutilisation. 

Enregistre l'inscription administrative d'un étudiant à un **inscrire** 

niveau d'étude pour une année donnée. 

Table technique qui enregistre quel utilisateur a lu quel **lecture\_message** 

message dans une conversation. 

Stocke le contenu de chaque message envoyé dans la **message\_chat** 

messagerie interne. 

Référentiel des niveaux d'accès aux données \(ex: Total, **niveau\_acces\_donne** 

Restreint\) pour le RBAC. 

Référentiel des niveaux d'étude \(ex: Master 1, Master 2 

**niveau\_etude** 

MIAGE\). 

Stocke les modèles et les contenus des notifications **notification** 

envoyées par le système. 

Historise les fonctions administratives occupées par un **occuper** 

enseignant dans le temps. 

Lie les utilisateurs aux conversations de la messagerie **participant\_conversation** 

auxquelles ils participent. 

Enregistre et suit les pénalités appliquées aux étudiants 

**penalite** 

pour soumission tardive. 

Contient les informations de profil des membres du 

**personnel\_administratif** 

personnel administratif. 

Table d'audit qui trace spécifiquement l'accès d'un 

**pister** 

utilisateur à un traitement \(permission\). 

Lie un PV de type "Session" à tous les rapports qui ont été **pv\_session\_rapport** 

traités dans cette session. 

Table centrale contenant les métadonnées de chaque 

**rapport\_etudiant** 

rapport de soutenance \(thème, résumé, statut...\). 

Table de liaison \(matrice\) du RBAC, qui associe les **rattacher** 

permissions \(traitement\) aux rôles \(groupe\_utilisateur\). 

Lie une notification à un utilisateur destinataire et suit son **recevoir** 

état de lecture. 

Stocke les réclamations soumises par les étudiants et leur **reclamation** 

traitement par l'administration. 

Lie un enseignant à un PV sur lequel il a agi \(ex: rédaction, **rendre** 

approbation\). 

Stocke le contenu textuel de chaque section d'un rapport 

**section\_rapport** 

d'étudiant. 

Table technique utilisée par le système pour générer des 

**sequences** 

identifiants uniques, lisibles et annuels. 

Table de liaison qui rattache les rapports à une session de **session\_rapport** 

validation spécifique. 

Représente une session de travail de la commission de **session\_validation** 

validation, avec ses dates, son mode et son statut. 

Table technique pour stocker les données de session PHP 

**sessions** 

en base de données \(pour la mise à jour des droits en temps réel\). 

Référentiel des spécialités de formation \(ex: MIAGE, Génie **specialite** 

Logiciel\). 

Référentiel des statuts de la vérification de conformité **statut\_conformite\_ref** 

\(Conforme, Non Conforme\). 

Référentiel du statut d'un enseignant dans une **statut\_jury** 

commission \(Président, Membre, Rapporteur\). 

**statut\_paiement\_ref** 

Référentiel des statuts de paiement des frais d'inscription. 

Référentiel des statuts d'une pénalité \(Due, Réglée, **statut\_penalite\_ref** 

Annulée\). 

Référentiel des statuts d'un Procès-Verbal \(En rédaction, 

**statut\_pv\_ref** 

En validation, Validé\). 

Référentiel des statuts d'un rapport tout au long de son **statut\_rapport\_ref** 

cycle de vie \(Brouillon, Soumis, En commission...\). 

Référentiel des statuts d'une réclamation \(Reçue, En **statut\_reclamation\_ref** 

cours, Clôturée\). 

Catalogue de toutes les permissions granulaires possibles 

**traitement** 

dans l'application pour le système RBAC. 

Référentiel des types de documents que le système peut 

**type\_document\_ref** 

générer \(PV, Attestation...\). 

Définit la catégorie générale d'un utilisateur \(Étudiant, **type\_utilisateur** 

Enseignant, Personnel Administratif...\). 

Référentiel 

des 

Unités 

d'Enseignement 

\(les 

**ue** 

regroupements de matières\). 

Table centrale pour tous les comptes utilisateurs, gérant 

**utilisateur** 

l'authentification et les accès. 

Enregistre l'action d'approbation d'un PV par chaque **validation\_pv** 

membre de la commission. 

Enregistre chaque vote individuel d'un membre de la **vote\_commission** 

commission pour un rapport donné dans une session. 



****

****

****

**Section 4 : Workflow de Rédaction et de Soumission du Rapport Étudiant** **7.1. Introduction : Une Approche Centrée sur l'Expérience Utilisateur** La conception du module de rédaction de la plateforme "GestionMySoutenance" a été guidée par un principe fondamental : offrir à l'étudiant une expérience d'édition à la fois puissante, flexible et familière. L'objectif est de reproduire la souplesse d'un logiciel de traitement de texte moderne, tel que Microsoft Word, pour minimiser la friction technique et permettre à l'étudiant de se concentrer sur la qualité de son contenu. 

Ce chapitre détaille le parcours complet de l'étudiant, depuis l'activation de ses droits de rédaction jusqu'à la soumission formelle de son rapport, en passant par les phases de correction. 

**7.2. Prérequis au Lancement du Processus **

L'accès à la fonctionnalité de rédaction n'est pas automatique. Il est conditionné par la validation du dossier administratif complet de l'étudiant. Ce processus est piloté par le Responsable Scolarité \(RS\) et agit comme un premier point de contrôle métier. Avant de pouvoir commencer la rédaction, un étudiant doit impérativement avoir : 1. Une inscription administrative validée pour l'année académique. 

2. Un statut de paiement des frais de scolarité à jour. 

3. Un stage officiellement enregistré et validé par l'administration. 

4. Régularisé toute pénalité de retard éventuelle. 

Ce n'est qu'après la vérification de ces prérequis que le RS active le compte de l'étudiant, lui ouvrant ainsi les portes de l'interface de rédaction. 

**7.3. Le Cycle de Vie de la Rédaction **

**7.3.1. Initialisation du Rapport **

Lors de sa première connexion, l'étudiant est invité à créer son espace de travail. Cette initialisation consiste à choisir un modèle de rapport pré-formaté ou de partir d'une structure vierge. Il doit également renseigner les métadonnées de son travail \(thème, directeur de mémoire pressenti...\). 

En arrière-plan, le système crée une nouvelle entrée dans la table rapport\_etudiant avec le statut RAP\_BROUILLON et génère les différentes fiches de section \(section\_rapport\) correspondantes au modèle choisi. 

**7.3.2. L'Interface d'Édition et la Sauvegarde Continue **

Le cœur de l'expérience utilisateur réside dans l'éditeur de texte riche \(WYSIWYG\). Pour chaque section de son rapport, l'étudiant dispose d'un environnement d'édition complet lui permettant de mettre en forme son texte, d'insérer des listes, des titres hiérarchisés ou des tableaux. 

Pour garantir une expérience sereine et éviter toute perte de données, un mécanisme de **sauvegarde automatique \(auto-save\)** est implémenté. Sans aucune action manuelle de l'étudiant, le système enregistre de manière continue et transparente le contenu de la section en cours de rédaction dans la base de données. 

**7.3.3. La Soumission Formelle **

Une fois que l'étudiant estime son travail achevé, il procède à la soumission via une action dédiée. Cet acte est un jalon critique et irréversible dans le workflow : 

• Le statut du rapport est mis à jour à RAP\_SOUMIS. 

• Le contenu de toutes les sections est verrouillé en lecture seule, empêchant toute modification ultérieure. 

• Une notification est automatiquement envoyée à l'étudiant pour accuser réception, ainsi qu'au service de Contrôle de Conformité pour l'informer qu'un nouveau rapport est prêt à être vérifié. 

**7.4. La Gestion du Circuit de Correction **

Le processus n'est pas toujours linéaire. Si un rapport est jugé non-conforme par l'administration, le système est conçu pour gérer ce retour de manière fluide. 

• L'étudiant est notifié du changement de statut de son rapport en RAP\_NON\_CONF. 

• L'interface de rédaction est automatiquement déverrouillée, lui permettant d'accéder de nouveau à ses sections pour y apporter les corrections demandées. 

• Les commentaires de l'agent de conformité sont affichés de manière claire et visible pour le guider. 

• Une fois les modifications effectuées, l'étudiant peut soumettre à nouveau son rapport corrigé, qui réintègre alors le circuit de validation. 

**7.5. Conclusion sur le Module de Rédaction **

En définitive, le module de rédaction de "GestionMySoutenance" est conçu pour offrir une expérience utilisateur souple et intuitive, tout en étant soutenu par un workflow applicatif rigoureux. L'approche de type "traitement de texte", combinée à un système de statuts et de notifications, garantit que la liberté créative de l'étudiant s'inscrit dans un cadre procédural qui assure la traçabilité, la conformité et l'efficacité du processus global de validation. 



**Section 5 : Conception du Module de Suivi de Dossier Étudiant** **5.1. Introduction et Objectifs **

Afin d'améliorer l'expérience utilisateur et de garantir une transparence totale tout au long du cycle de vie d'un rapport de soutenance, un module de suivi de dossier dynamique est intégré à l'Espace Étudiant. L'objectif principal de cette fonctionnalité est de transformer une période d'attente, souvent source d'incertitude, en un processus guidé et informatif. 

Ce module vise à : 

• Fournir à l'étudiant une **visibilité en temps réel** sur l'état d'avancement de son dossier. 

• **Contextualiser le statut actuel** au sein du workflow global de validation. 

• **Communiquer de manière proactive** les actions requises, notamment en cas de demande de correction. 

• **Réduire la charge de support** pour le personnel administratif en répondant par avance aux questions de suivi des étudiants. 

**5.2. Architecture Fonctionnelle **

La conception retenue repose sur une approche visuelle et intuitive, décomposée en deux éléments d'interface complémentaires, pilotés par une logique serveur robuste. 

**5.2.1. Le Visualiseur de Workflow \("Stepper"\)** L'élément central de l'interface est une représentation graphique de la progression du rapport. 

Il prend la forme d'une ligne de temps verticale qui matérialise l'ensemble des étapes prédéfinies du processus de validation, de la soumission initiale à l'archivage final. 

Chaque étape de cette ligne de temps est affichée avec un état visuel distinct pour une compréhension immédiate : 

• **Étape Terminée :** Indiquée par une icône de validation \(ex: \) et la date à laquelle l'étape a été franchie. 

• **Étape Actuelle :** Mise en exergue visuellement \(ex: \) pour signifier la position présente du dossier dans le processus. 

• **Étape Future :** Représentée de manière neutre \(ex: \), informant l'étudiant des jalons à venir. 

Cet affichage est directement gouverné par la colonne etape\_workflow de la table de référence statut\_rapport\_ref, garantissant un ordre logique et constant. 

**5.2.2. Le Panneau d'Information Contextuelle** 

Adjacent au visualiseur de workflow, un panneau de détails fournit des informations spécifiques à l'étape actuelle. Le contenu de ce panneau est dynamique et s'adapte au statut du rapport : 

• **Information Générale :** Pour les statuts d'attente \(ex: "En Commission"\), un message explicatif rassure l'étudiant et précise qu'aucune action n'est requise de sa part. 

• **Information Spécifique et Action Requise :** Dans les cas où une intervention de l'étudiant est nécessaire \(ex: statut "Non Conforme"\), le panneau affiche : 1. Un titre clair signalant une action requise. 

2. Les commentaires détaillés et constructifs saisis par le personnel administratif ou les membres de la commission. 

3. Un bouton d'appel à l'action \(ex: "Modifier mon rapport"\) qui déverrouille les fonctionnalités d'édition nécessaires. 

**5.3. Orchestration Technique et Flux de Données **

La robustesse de cette fonctionnalité repose sur une dissociation claire entre la logique de présentation \(frontend\) et la logique métier \(backend\), qui s'appuie sur le modèle de données existant. 

1. **Source de Vérité :** La table statut\_rapport\_ref définit la "carte" du workflow, tandis que la clé étrangère id\_statut\_rapport dans la table rapport\_etudiant agit comme un "pointeur" 

indiquant la position actuelle. 

2. **Historisation :** La table d'audit enregistrer sert de mémoire au système. Chaque transition de statut d'un rapport y est consignée avec un horodatage précis, permettant de reconstituer l'historique daté des étapes franchies. 

3. **Flux de Données :** Lors de la consultation, le serveur orchestre la collecte des données 

: il identifie le statut actuel du rapport, récupère la définition complète du workflow, 

interroge le journal d'audit pour l'historique, et collecte les informations contextuelles \(comme les commentaires de non-conformité depuis la table approuver\). 

4. **Présentation :** Le serveur assemble ces informations en un objet de données unique et structuré, que l'interface utilisateur se charge uniquement d'afficher. Cette architecture garantit que toute modification du workflow \(ajout/suppression d'une étape\) ne nécessite qu'une mise à jour des données de référence, sans impacter le code applicatif. 

**5.4. Conclusion **

L'approche de suivi de workflow visuel et dynamique constitue une plus-value majeure pour la plateforme "GestionMySoutenance". En offrant clarté, guidage et autonomie à l'étudiant, elle améliore significativement son expérience tout en optimisant les processus administratifs. Sa conception, solidement ancrée dans le modèle de données, assure une solution à la fois robuste, maintenable et évolutive. 



**Section 6 : Conception du Circuit de Correction des Rapports** **6.1. Introduction et Objectifs **

La gestion des corrections est une étape interactive fondamentale du processus de validation. 

Qu'elle fasse suite à une vérification de conformité administrative ou à une évaluation académique par la commission, elle doit être gérée par un mécanisme à la fois clair pour l'étudiant et efficace pour les évaluateurs. 

L'objectif de ce module est de mettre en œuvre une **boucle de rétroaction intégrée et traçable** sans alourdir le schéma de la base de données. La solution retenue s'appuie sur l'optimisation des tables existantes pour : 

• **Déverrouiller** l'interface de rédaction de manière conditionnelle pour l'étudiant. 

• **Présenter** les demandes de correction de manière contextuelle. 

• **Capturer** et **transmettre** une note explicative rédigée par l'étudiant lors de sa nouvelle soumission. 

• **Garantir** une piste d'audit complète de chaque cycle de correction. 

**6.2. Architecture Fonctionnelle et Logique **

La fonctionnalité est conçue comme un cycle en trois phases, orchestré par le statut du rapport et exploitant la flexibilité de la table d'audit. 

**6.2.1. Phase 1 : Déclenchement du Cycle de Correction** 

Le processus est initié par un évaluateur. En changeant le statut d'un rapport à **RAP\_NON\_CONF** 

\(pour une non-conformité administrative\) ou **RAP\_CORRECT** \(pour des corrections académiques\), le système active le mode "correction". Les commentaires et justifications de l'évaluateur sont enregistrés dans les tables prévues à cet effet \(approuver ou vote\_commission\), fournissant le contexte nécessaire à l'étudiant. 

**6.2.2. Phase 2 : Interface de Correction de l'Étudiant** 

Suite au changement de statut, l'environnement de l'étudiant s'adapte dynamiquement : 

1. **Déverrouillage Conditionnel :** Le système de contrôle d'accès autorise l'édition du rapport. L'interface de rédaction \(WYSIWYG\), précédemment en lecture seule, redevient pleinement fonctionnelle. 

2. **Affichage Contextuel :** Les commentaires de l'évaluateur sont affichés de manière proéminente au sein de l'interface, permettant à l'étudiant de travailler sur ses modifications tout en ayant les instructions sous les yeux. 

3. **Champ de Note Explicative :** Un champ de saisie de texte obligatoire est présenté à l'étudiant. Il est invité à y résumer les modifications apportées, facilitant ainsi le travail de ré-évaluation. 

**6.2.3. Phase 3 : Re-soumission et Traçabilité** 

L'acte de re-soumission par l'étudiant est un événement métier clé, géré de la manière suivante 

: 

1. **Capture de la Note :** Le contenu de la note explicative est encapsulé dans un champ JSON au sein de la table d'audit enregistrer. 

2. **Audit de l'Action :** Une nouvelle entrée est créée dans la table enregistrer avec une id\_action spécifique \(ex: SOUMISSION\_CORRECTION\). Cette entrée lie l'étudiant, le rapport, la date, et la note explicative, créant un enregistrement d'audit atomique et complet. 

3. **Mise à Jour du Statut :** Le statut du rapport est mis à jour pour le réintégrer dans le circuit de validation \(ex: retour à RAP\_SOUMIS\). 

4. **Verrouillage :** L'interface d'édition est de nouveau verrouillée en lecture seule. 

**6.3. Implémentation Technique sans Table Additionnelle **

La décision de ne pas créer de table dédiée à la note de correction repose sur une utilisation intelligente de la table enregistrer. Le champ details\_action \(de type JSON\) est mis à profit pour stocker des données contextuelles riches. 

• **Stockage :** La note explicative est stockée sous une clé spécifique \(ex: 

"note\_explicative": "..."\) dans le champ details\_action de l'enregistrement d'audit correspondant à l'action de re-soumission. 

• **Récupération :** Lorsqu'un évaluateur consulte une version corrigée, le système effectue une requête ciblée sur la table enregistrer pour extraire et afficher la dernière note soumise par l'étudiant pour ce rapport. 

**6.4. Conclusion **

Cette approche de gestion des corrections est à la fois élégante et robuste. Elle offre une expérience utilisateur guidée et transparente sans nécessiter de modification structurelle du schéma de la base de données. En exploitant la flexibilité de la table d'audit existante, le système garantit une traçabilité complète et sémantiquement cohérente de chaque cycle de correction, tout en maintenant un modèle de données concis et maîtrisé. 





**Section 7 : Processus d'Activation des Droits et de Création des Comptes Étudiants** **7.1. Rôle et Mission **

L'accès d'un étudiant à la plateforme "GestionMySoutenance" n'est pas automatique. Il est conditionné par la validation formelle de son dossier administratif par le Responsable Scolarité \(RS\). Cette étape cruciale agit comme un point de contrôle métier, garantissant que seuls les étudiants administrativement aptes peuvent initier le processus de rédaction et de soumission de leur rapport. 

L'objectif de cette fonctionnalité est de fournir au RS un outil efficace et sécurisé pour : 1. **Vérifier** les prérequis administratifs de manière centralisée. 

2. **Créer** les comptes utilisateurs pour les étudiants éligibles. 

3. **Automatiser** la communication des identifiants de connexion. 

La conception de l'interface permet au RS de traiter les dossiers individuellement ou **par lots**, optimisant ainsi son temps de travail en début ou en cours d'année académique. 

**7.2. Architecture Fonctionnelle **

La solution repose sur la dissociation fondamentale entre l'entité administrative \(etudiant\) et l'entité d'accès \(utilisateur\). Un enregistrement peut exister dans la table etudiant sans avoir de compte utilisateur correspondant \(le champ de liaison numero\_utilisateur étant NULL\). 

L'activation consiste précisément à créer ce compte et à établir cette liaison. 

**7.2.1. L'Interface de Validation du Responsable Scolarité \(RS\)** Le RS dispose d'un tableau de bord dédié, "Dossiers en attente de création de compte", qui liste tous les étudiants n'ayant pas encore d'accès à la plateforme. 

• **Vue par Lots :** L'interface présente une liste tabulaire des étudiants éligibles. Chaque ligne correspond à un étudiant et affiche : 

o Son identité \(Nom, Prénom, N° de carte\). 

o Une série de colonnes "Checklist" qui valident visuellement chaque prérequis : 

▪ **Paiement Scolarité :** / \(basé sur la table inscrire\). 

▪ **Validation Stage :** / \(basé sur la table faire\_stage\). 

▪ **Pénalités Régularisées :** / \(basé sur la table penalite\). 

o Une case à cocher \(checkbox\) pour la sélection. 

• **Logique de Sélection :** Le RS peut cocher les cases des étudiants qu'il souhaite activer. 

De manière cruciale, **la case à cocher d'un étudiant est désactivée \(grisée\) si l'un de** **ses prérequis n'est pas rempli**. Cela empêche toute erreur de sélection et garantit que seuls les dossiers complets peuvent être traités. 

• **Action Groupée :** Un unique bouton d'action, **"Valider et Créer les Comptes** **Sélectionnés" **, est présent en haut ou en bas de la liste. Il s'active dès qu'au moins un étudiant éligible est sélectionné. 

**7.3. Algorithme de Création et de Notification par Lots** Lorsque le RS clique sur le bouton d'action, le système exécute une boucle sur tous les étudiants sélectionnés. Pour chaque étudiant, il initie une **transaction individuelle** pour garantir l'intégrité de chaque création de compte. 

Le processus pour chaque étudiant est le suivant : 1. **Génération des Données :** Le système génère un identifiant utilisateur unique \(ex: ETU-2024-xxxx\), un login par défaut, et un mot de passe temporaire sécurisé. 

2. **Création du Compte :** Une nouvelle entrée est insérée dans la table utilisateur. Le mot de passe temporaire y est stocké sous forme hachée, et le statut du compte est immédiatement défini sur 'actif'. 

3. **Liaison des Entités :** La table etudiant est mise à jour pour y inscrire le nouvel numero\_utilisateur, liant ainsi le dossier administratif au compte d'accès. 

4. **Audit :** L'action de création est consignée dans la table enregistrer, identifiant le RS 

comme l'opérateur et l'étudiant comme l'entité concernée. 

5. **Mise en File de la Notification :** Une fois la transaction pour un étudiant réussie, le système ajoute une tâche à une file d'attente pour l'envoi d'un email. 

Une fois la boucle terminée, un service indépendant traite la file d'attente et envoie à chaque nouvel utilisateur un email de bienvenue personnalisé, contenant son login et son mot de passe temporaire, avec l'instruction de le modifier à la première connexion. 

**7.4. Conclusion **

Cette approche de validation et de création par lots offre un équilibre optimal entre contrôle, sécurité et efficacité. Elle confère au Responsable Scolarité un pouvoir de validation final et délibéré, tout en lui fournissant les outils pour traiter de grands volumes de dossiers rapidement. 

La logique de désactivation des sélections non conformes prévient les erreurs humaines, et l'automatisation de la création de compte et de l'envoi des identifiants garantit un processus fiable, traçable et professionnel. 



**Section 8 : Détection et Gestion des Pénalités de Retard** **8.1. Introduction et Objectifs **

Afin d'assurer le respect des délais de finalisation des études et de garantir une application équitable des règlements de l'établissement, la plateforme "GestionMySoutenance" intègre un module de détection et de gestion des pénalités pour retard de soutenance. Ce processus est un prérequis essentiel à la création du compte utilisateur, assurant qu'aucun étudiant en situation irrégulière ne puisse initier son parcours de soumission. 

Les objectifs de cette fonctionnalité sont : 

• **Détecter automatiquement et systématiquement** les étudiants ayant dépassé le délai réglementaire pour la validation de leur rapport. 

• **Créer une trace formelle** de chaque pénalité due dans le système. 

• **Fournir au Responsable Scolarité \(RS\)** les informations nécessaires pour gérer la régularisation de ces pénalités. 

• **Bloquer la création de compte** tant que la situation administrative de l'étudiant n'est pas entièrement régularisée. 

**8.2. Architecture Fonctionnelle : Une Approche Hybride **

La solution retenue est une approche hybride qui combine une détection automatisée avec une gestion manuelle, garantissant à la fois l'efficacité, l'objectivité et le contrôle humain. 

**8.2.1. Détection Automatisée par Tâche Planifiée \(CRON Job\)** Le cœur de la détection est un script automatisé qui s'exécute périodiquement \(ex: de manière nocturne\). Ce script agit comme un auditeur proactif et infatigable. Son rôle est de : 1. **Identifier la Population Cible :** Le script cible exclusivement les étudiants inscrits au niveau d'étude final \(ex: Master 2\) et qui ne disposent pas encore d'un compte utilisateur actif \(numero\_utilisateur est NULL\). 

2. **Calculer le Retard :** Pour chaque étudiant cible, il compare son année d'inscription initiale \(issue de la table inscrire\) à l'année académique en cours. 

3. **Appliquer les Règles Métier :** Si le nombre d'années écoulées dépasse le seuil défini par l'établissement \(ex: plus d'un an après l'année nominale de fin d'études\), une pénalité est déclenchée. 

4. **Générer la Pénalité :** Si aucune pénalité n'est déjà enregistrée pour l'année en cours, le script crée une nouvelle entrée dans la table penalite avec le statut PEN\_DUE. Cette action est auditée et une notification est envoyée au RS pour l'informer de la nouvelle pénalité générée. 

Ce processus garantit que la table penalite est constamment à jour et reflète l'état administratif réel de tous les étudiants en attente, avant même toute intervention du RS. 

**8.2.2. Processus de Validation et de Régularisation par le RS** 

L'interface du RS pour la création des comptes est directement alimentée par les informations générées par le script. 

1. **Consultation du Dossier :** Lorsque le RS consulte le dossier d'un étudiant en attente, l'interface affiche une checklist de prérequis en temps réel. 

2. **Vérification de la Pénalité :** L'un des points de cette checklist est la "Régularisation des Pénalités". Le système vérifie dans la table penalite si une entrée avec le statut PEN\_DUE 

existe pour l'étudiant. 

3. **Contrôle de l'Action :** 

o **Si une pénalité est due**, la condition est marquée comme non remplie \( \). Par conséquent, l'option de sélectionner cet étudiant pour la création de compte est **désactivée**, empêchant toute erreur de la part du RS. 

o **Si aucune pénalité n'est due**, la condition est validée \( \). 

4. **Régularisation Manuelle :** Il incombe au RS de gérer le processus de régularisation avec l'étudiant. Une fois la pénalité soldée, le RS utilise son interface de gestion pour mettre à jour le statut de l'entrée dans la table penalite de PEN\_DUE à PEN\_REGLEE. 

5. **Déblocage :** Suite à cette mise à jour, lors d'une nouvelle consultation du dossier, la condition de pénalité sera validée, rendant l'étudiant éligible à la création de son compte \(si les autres prérequis sont également remplis\). 

**8.3. Conclusion **

Cette synergie entre un automate de détection et un opérateur humain de gestion constitue une solution robuste et sécurisée. L'automatisation assure une application systématique et équitable des règles, tandis que le contrôle manuel par le RS garantit que les actions critiques 

– la régularisation d'une pénalité et la création d'un compte – restent des décisions humaines, délibérées et traçables. Ce mécanisme préventif est fondamental pour l'intégrité du processus de soutenance. 

Absolument. Voici le résumé de cette fonctionnalité, structuré au format rapport. 



**Section 9 : Création et Gestion des Sessions de Validation** **9.1. Rôle et Objectifs **

La Session de Validation est le concept central qui structure le travail d'évaluation de la commission pédagogique. Elle agit comme un **conteneur de travail dynamique**, permettant au Président de la commission \(ou à un membre délégué\) de regrouper, gérer et suivre l'évaluation de plusieurs rapports de manière organisée. 

Les objectifs de ce module sont de fournir une interface intuitive pour : 

• **Créer** des sessions de travail flexibles. 

• **Composer** dynamiquement le lot de rapports à évaluer. 

• **Piloter** le cycle de vie de la session, de sa préparation à sa clôture. 

• **Automatiser** la communication avec les membres de la commission. 

**9.2. Architecture Fonctionnelle : Le Cycle de Vie de la Session** La fonctionnalité est conçue autour d'un cycle de vie en trois états, qui offre un maximum de flexibilité et de contrôle au Président de session. Ce cycle est matérialisé par le champ statut\_session dans la table session\_validation. 

**9.2.1. Phase 1 : Planification et Composition \(Statut : planifiee\)** C'est la phase de préparation. 

1. **Création :** Le Président initie une nouvelle session via un formulaire simple, en définissant ses propriétés de base comme son nom \(nom\_session\) et ses dates prévisionnelles. À ce stade, la session est créée avec le statut planifiee. 

2. **Composition :** Le Président accède à une interface de gestion dédiée. Cette interface lui présente la liste de tous les rapports éligibles \(ceux ayant le statut RAP\_CONF et n'étant pas déjà affectés à une autre session active\). Il peut alors dynamiquement **ajouter ou** **retirer** des rapports de sa session. Cette phase permet de constituer le lot de travail de manière itérative et réfléchie. 

**9.2.2. Phase 2 : Exécution de l'Évaluation \(Statut : en\_cours\)** Cette phase est déclenchée par une action manuelle et délibérée du Président. 

1. **Démarrage :** Lorsque la composition de la session est finalisée, le Président la "démarre". 

Cette action fait passer le statut à en\_cours. 

2. **Verrouillage et Notification :** Le démarrage de la session a deux effets immédiats : o La composition de la session est **verrouillée** ; il n'est plus possible d'y ajouter ou d'en retirer des rapports, garantissant un périmètre d'évaluation stable. 

o Une **notification** est automatiquement envoyée à tous les membres de la commission, les informant du début de la session et les invitant à procéder à l'évaluation des rapports concernés. 

**9.2.3. Phase 3 : Finalisation et Archivage \(Statut : cloturee\)** C'est l'étape de conclusion du travail d'évaluation. 

1. **Condition de Clôture :** Le système n'autorise la clôture d'une session que lorsque tous les rapports qui y sont rattachés ont fait l'objet d'une décision finale \(ex: unanimité des votes atteinte\). 

2. **Clôture Manuelle :** Le Président déclenche la clôture de la session. Le statut passe à cloturee. 

3. **Archivage :** La session devient un enregistrement historique non modifiable. Cette étape est le prérequis à la génération du Procès-Verbal \(PV\) de session, qui formalise l'ensemble des décisions prises. 

**9.3. Implémentation Technique **

La mise en œuvre de cette fonctionnalité s'appuie sur l'interaction de plusieurs tables clés : 

• **session\_validation** stocke les métadonnées et l'état du cycle de vie de la session. 

• **session\_rapport** est la table de liaison qui matérialise l'association entre une session et les rapports qu'elle contient. 

• **rapport\_etudiant** et **vote\_commission** sont interrogées pour, respectivement, peupler la liste des rapports éligibles et suivre la progression des évaluations. 

**9.4. Conclusion **

L'approche de la session comme "conteneur de travail dynamique" offre une solution puissante et flexible, parfaitement adaptée aux réalités du pilotage d'une commission pédagogique. Elle assure la traçabilité, la structuration du travail par lots, et une communication efficace, tout en laissant au Président une maîtrise complète du calendrier et du périmètre de chaque cycle d'évaluation. 



**Section 10 : Algorithme de Vote et de Gestion du Consensus** **10.1. Rôle et Objectifs **

Le mécanisme de vote constitue le moteur décisionnel du module de la Commission de Validation. Il est conçu pour orchestrer de manière fiable, sécurisée et traçable le processus d'évaluation collégiale des rapports. L'algorithme a pour mission de formaliser chaque vote individuel et de déterminer si un consensus, basé sur la règle métier de l'unanimité, est atteint. 

Les objectifs principaux de cet algorithme sont : 

• **Enregistrer** chaque vote de manière atomique et non répudiable. 

• **Déclencher** une vérification du consensus en temps réel après chaque vote soumis. 

• **Appliquer** la décision finale au rapport lorsque l'unanimité est constatée. 

• **Gérer** les situations de désaccord en plaçant le rapport dans un état de délibération et en alertant le Président de session. 

• **Permettre** la tenue de plusieurs tours de scrutin pour résoudre les blocages. 

**10.2. Architecture Fonctionnelle : Un Processus Événementiel** La logique de consensus n'est pas une tâche périodique mais un **processus événementiel**. Il est déclenché par l'action d'un membre de la commission soumettant son vote. Cette approche garantit une réactivité maximale : l'état du rapport est réévalué instantanément à chaque nouvelle information. 

Le processus s'articule autour de la table vote\_commission, qui agit comme le registre officiel de tous les votes. La colonne tour\_vote est fondamentale, car elle permet d'isoler les scrutins les uns des autres en cas de délibérations multiples. 

**10.3. Séquence Opérationnelle Détaillée **

L'algorithme se déroule en plusieurs étapes clés après chaque soumission de vote. 

1. **Enregistrement du Vote :** 

o Lorsqu'un membre soumet sa décision, une nouvelle entrée est créée dans la table vote\_commission. Cette entrée contient l'identifiant du rapport, de la session, du membre, sa décision \(id\_decision\_vote\), et le numéro du tour de scrutin en cours \(tour\_vote\). L'opération est transactionnelle pour garantir son intégrité. 

2. **Vérification du Scrutin :** 

o Immédiatement après l'enregistrement, un service applicatif est appelé. Il compte le nombre total de votes enregistrés pour le rapport et le tour de scrutin actuels. 

o Tant que le nombre de votes est inférieur au nombre de membres requis \(ex: 4\), l'algorithme s'arrête, en attente des votes restants. 

3. **Analyse du Consensus \(lorsque le scrutin est complet\) :** o Lorsque le dernier vote est enregistré, le service procède à l'analyse des décisions : 

▪ **Cas 1 : Unanimité Atteinte. ** Si toutes les décisions \(id\_decision\_vote\) enregistrées pour le tour sont identiques, le consensus est atteint. 

L'algorithme traduit alors cette décision unanime en un statut final pour le rapport \(ex: RAP\_VALID, RAP\_REFUSE, RAP\_CORRECT\) en mettant à jour la table rapport\_etudiant. 

▪ **Cas 2 : Désaccord Constaté. ** Si au moins une décision diffère des autres, l'unanimité a échoué. L'algorithme met alors le rapport dans un statut d'attente spécifique \(EN\_DELIBERATION\) et envoie une notification au Président de session pour l'alerter du blocage. 

**10.4. Gestion des Tours de Vote Multiples **

En cas de désaccord, le système donne au Président les moyens de résoudre le blocage. 

1. **Action du Président :** L'interface du Président, alertée du désaccord, lui présente une option pour "Lancer un nouveau tour de vote". 

2. **Incrémentation du Tour :** Cette action ne supprime pas les votes précédents \(pour la traçabilité\). Elle prépare le système pour un nouveau scrutin en incrémentant la valeur de tour\_vote pour ce rapport \(ex: passage du tour 1 au tour 2\). 

3. **Réouverture du Vote :** Les membres de la commission sont notifiés et leur interface de vote pour ce rapport est réactivée, mais cette fois pour le nouveau tour. Le cycle de vote et de vérification du consensus recommence, isolé du tour précédent. 

**10.5. Conclusion **

Cet algorithme événementiel et transactionnel garantit un processus de décision robuste et transparent. Il assure que chaque vote est comptabilisé, que le consensus est vérifié de manière fiable, et que les situations de désaccord sont gérées par un processus formel et traçable. La gestion des tours de vote multiples offre la flexibilité nécessaire aux délibérations complexes, tout en maintenant une piste d'audit complète de l'ensemble du processus décisionnel. 



**Section 11 : Génération, Rédaction Collaborative et Validation du Procès-Verbal de Session** **11.1. Rôle et Objectifs **

La production du Procès-Verbal \(PV\) de session est l'acte final qui formalise et archive l'ensemble des décisions prises par la commission. Cette fonctionnalité est conçue pour encadrer la création d'un document officiel, de sa rédaction initiale à sa diffusion finale, en passant par un circuit de validation collégiale. 

Les objectifs de ce module sont de : 

• **Automatiser** la compilation des données de la session pour pré-remplir le PV. 

• **Gérer** la rédaction du PV via un mécanisme de **propriété et de délégation**, assurant qu'un seul membre peut modifier le document à un instant T. 

• **Orchestrer** un circuit d'approbation interne sécurisé où chaque membre de la commission doit valider la version finale. 

• **Garantiser** la génération d'un document PDF authentique et sa diffusion contrôlée aux parties prenantes \(étudiants, administration\). 

**11.2. Architecture Fonctionnelle : Un Cycle de Vie Contrôlé** Le processus est modélisé comme une machine à états, pilotée par le statut du PV \(id\_statut\_pv\) et une notion de "propriétaire de la rédaction" \(id\_redacteur\). 

**11.2.1. Phase 1 : Prise en Charge et Rédaction \(Statut : PV\_BROUILLON\)** 1. **Déclenchement :** Une fois qu'une session est clôturée, l'option "Rédiger le Procès-Verbal" devient disponible pour tous les membres de la commission. 

2. **Prise de Propriété \("Verrouillage"\) :** Le **premier membre** qui clique sur cette option devient le **propriétaire-rédacteur** du PV. Le système exécute alors les actions suivantes 

: 

o Il crée une nouvelle entrée dans la table compte\_rendu avec le statut PV\_BROUILLON. 

o Le champ id\_redacteur est renseigné avec l'identifiant de ce premier membre. 

o Un squelette de document est automatiquement généré en compilant les données de la session \(participants, liste des rapports, décisions, commentaires agrégés\). 

3. **Interface de Rédaction :** 

o Le propriétaire-rédacteur accède à une interface d'édition de texte riche \(WYSIWYG\) pour compléter les sections textuelles du PV. 

o Pour tous les autres membres, l'option de rédaction est remplacée par un message indiquant qui est actuellement en charge de la rédaction, garantissant ainsi qu'il n'y a pas de modifications concurrentes. 

**11.2.2. Phase 2 : Délégation de la Rédaction \(Optionnel\)** Le propriétaire-rédacteur actuel dispose d'une fonctionnalité pour "Déléguer la rédaction". Cela lui permet de passer le relais à un autre membre de la commission. Cette action met simplement à jour le champ id\_redacteur dans la table compte\_rendu, transférant ainsi le "verrou" d'édition au nouveau membre désigné. L'opération est auditée et les parties concernées sont notifiées. 

**11.2.3. Phase 3 : Validation Collégiale \(Statut : PV\_SOUMIS\_VALID\)** 1. **Soumission à Validation :** Lorsque la rédaction est jugée complète, le propriétaire-rédacteur soumet le projet de PV à la validation de ses pairs. Le statut du PV passe à PV\_SOUMIS\_VALID. 

2. **Circuit d'Approbation :** Le document devient accessible en lecture seule pour tous les membres. Chacun doit formellement donner son avis via l'interface : o **Approuver :** L'approbation est enregistrée dans la table validation\_pv. 

o **Demander une Modification :** Si un membre n'est pas d'accord, il peut rejeter la version en laissant un commentaire. Cette action réinitialise le statut du PV à PV\_BROUILLON et notifie le dernier rédacteur, qui reprend la main pour effectuer les ajustements. 

3. **Consensus :** Le PV n'est considéré comme finalisé que lorsque le système a enregistré une approbation de la part de **tous les membres** de la commission. 

**11.2.4. Phase 4 : Finalisation et Diffusion \(Statut : PV\_VALID\)** Cette phase est déclenchée automatiquement dès que le consensus est atteint. 

1. **Génération du PDF :** Le système convertit le contenu HTML final du PV en un document PDF non modifiable, qui est ensuite archivé dans la table document\_genere. 

2. **Diffusion Automatisée :** Le PDF est immédiatement et automatiquement distribué aux parties prenantes principales : 

o **Étudiants :** Chaque étudiant dont le rapport a été traité dans la session reçoit une copie dans son espace personnel. 

o **Agent de Conformité :** Le personnel administratif responsable du suivi reçoit également une copie pour ses archives. 

3. **Diffusion Complémentaire :** L'interface permet au Président d'envoyer manuellement une copie du PDF final à des adresses email externes si nécessaire. 

**11.3. Conclusion **

Cette approche garantit un processus de création de document officiel à la fois collaboratif et rigoureusement contrôlé. Le mécanisme de propriété et de délégation prévient les conflits d'édition, tandis que le circuit de validation collégiale assure que le document final reflète bien le consensus de la commission. L'automatisation de la compilation et de la diffusion finale réduit la charge de travail et minimise les risques d'erreur, assurant la production d'un Procès-Verbal authentique, validé et correctement archivé. 



**Section 12 : Service de Génération d'Identifiants Uniques et Annuels** **12.1. Contexte et Objectifs **

Dans le cadre de la plateforme "GestionMySoutenance", il a été décidé d'adopter une stratégie d'identification métier pour les entités clés \(rapports, utilisateurs, procès-verbaux, etc.\). Cette approche vise à remplacer les identifiants techniques opaques \(ex: auto-incréments, UUID\) par des clés primaires lisibles, structurées et riches en information, suivant la convention PREFIXE-ANNEE-SEQUENCE \(ex: RAP-2025-0015\). 

Les objectifs de ce service technique, nommé IdentifiantGenerator, sont de : 

• **Garantir l'unicité absolue** de chaque identifiant généré à travers toute l'application. 

• **Assurer la pérennité et la cohérence** de la séquence numérique. 

• **Gérer la remise à zéro automatique** des compteurs pour chaque nouvelle année académique. 

• **Fournir une solution robuste** face aux accès concurrents, prévenant toute possibilité de création de doublons \("race condition"\). 

**12.2. Architecture Technique : Un Compteur Transactionnel Sécurisé** La solution repose sur la synergie entre une table de base de données dédiée et un algorithme applicatif qui utilise les mécanismes transactionnels du SGBD. 

**12.2.1. La Table sequences : Le Registre des Compteurs** 

Le cœur du système est la table sequences. Sa structure est spécifiquement conçue pour gérer des compteurs annuels : 

• Une clé primaire composite \(nom\_sequence, annee\) garantit qu'un compteur est unique pour une année donnée \(ex: 'rapport' pour 2025\). 

• La colonne valeur\_actuelle stocke le dernier numéro séquentiel utilisé pour ce compteur cette année-là. 

Cette structure permet une remise à zéro "naturelle" des compteurs : la première demande d'identifiant pour une nouvelle année créera simplement une nouvelle ligne dans la table. 

**12.2.2. L'Algorithme du Service IdentifiantGenerator** 

Toute la logique de génération est centralisée dans un unique service applicatif. Son fonctionnement est conçu pour être atomique et sécurisé. 

1. **Démarrage d'une Transaction :** Chaque demande de génération d'ID initie une transaction de base de données, assurant que la séquence d'opérations est un bloc indivisible \(tout réussit ou tout échoue\). 

2. **Verrouillage Pessimiste de Ligne \(FOR UPDATE\) :** C'est l'étape la plus critique. Le service lit la valeur actuelle du compteur en demandant un **verrou exclusif** sur la ligne correspondante dans la table sequences. Cette instruction SELECT ... FOR UPDATE force tout autre processus tentant d'accéder à cette même ligne à se mettre en attente. 

3. **Incrémentation et Mise à Jour :** Une fois le verrou obtenu et la valeur lue, le service l'incrémente en mémoire. Il met ensuite à jour la base de données avec la nouvelle valeur en utilisant une commande INSERT ... ON DUPLICATE KEY UPDATE, qui gère de manière atomique la création \(pour le premier ID de l'année\) ou la mise à jour de la ligne du compteur. 

4. **Validation de la Transaction :** Le service exécute un COMMIT, ce qui valide la mise à jour et, surtout, **libère le verrou** sur la ligne. C'est seulement à cet instant qu'un autre processus en attente peut commencer son propre cycle de lecture-verrouillage-écriture. 

5. **Formatage et Retour :** Le service formate le numéro séquentiel obtenu \(ex: ajout de zéros non significatifs\) et l'assemble avec le préfixe et l'année pour retourner l'identifiant final complet. 

**12.3. Garantie de l'Unicité en Environnement Concurrentiel** Le choix d'une transaction avec un verrou pessimiste FOR UPDATE est délibéré et constitue la solution la plus robuste pour ce type de problématique. Il prévient les "race conditions" en sérialisant les accès au compteur : si deux requêtes arrivent simultanément, la base de données elle-même garantit que la seconde attendra la fin de la première avant de s'exécuter, assurant ainsi une séquence numérique parfaite et sans doublons. 

**12.4. Conclusion **

Le service IdentifiantGenerator est une fondation technique essentielle de l'application. En centralisant la logique de génération et en s'appuyant sur les mécanismes transactionnels avancés de la base de données, il fournit des identifiants à la fois significatifs pour les utilisateurs et techniquement uniques et fiables. Cette approche garantit l'intégrité des données, facilite l'audit et améliore l'ergonomie générale de la plateforme "GestionMySoutenance". 



**Section 13 : Traçabilité, Audit et Historisation des Données** **13.1. Introduction et Objectifs **

La fiabilité et l'intégrité d'un système d'information tel que "GestionMySoutenance" reposent sur sa capacité à conserver une mémoire fidèle des actions et des évolutions de données au fil du temps. Cette section détaille les deux piliers de cette mémoire système : la piste d'audit des actions critiques et l'historisation des carrières du personnel. 

Les objectifs de ces fonctionnalités sont de : 

• **Garantir une traçabilité complète** de toutes les opérations sensibles effectuées sur la plateforme. 

• **Fournir un journal d'audit détaillé** pour des besoins de sécurité, de support technique et de conformité réglementaire. 

• **Assurer une gestion précise du cycle de vie** des carrières du personnel, permettant de reconstituer les responsabilités à n'importe quel point dans le temps. 



**13.2. Fonctionnalité : Piste d'Audit et Traçabilité des Actions** **13.2.1. Architecture Fonctionnelle **

Le système intègre un mécanisme de journalisation centralisé, conçu pour intercepter et enregistrer de manière systématique toutes les actions critiques. Plutôt que de disperser la logique d'audit, l'application s'appuie sur un service AuditLogger ou un système d'événements découplé. Chaque fois qu'une opération sensible est réalisée, un événement est émis et capturé par un "écouteur" d'audit, qui se charge de créer une entrée détaillée. 

Ce mécanisme répond à la question fondamentale : **"Qui a fait quoi, sur quoi, quand et depuis** **où ?" **. 

**13.2.2. Implémentation Technique **

La mise en œuvre s'articule autour de la table enregistrer, dont la structure est spécifiquement conçue pour la journalisation : 

• **numero\_utilisateur** identifie l'auteur de l'action \(le "Qui"\). 

• **id\_action** 

catégorise l'événement \(le "Quoi", ex: CONNEXION\_REUSSIE, CHANGEMENT\_STATUT\_RAPPORT\). 

• **date\_action** fournit l'horodatage précis \(le "Quand"\). 

• **id\_entite\_concernee** et **type\_entite\_concernee** lient l'action à un objet métier spécifique \(le "Sur Quoi", ex: un rapport, une session\). 

• **details\_action** \(JSON\) stocke des informations contextuelles riches \(le "Comment", ex: l'ancienne et la nouvelle valeur d'un champ\). 

• **adresse\_ip** et **user\_agent** fournissent le contexte technique de l'action. 

Toutes les opérations critiques, telles que les connexions, les modifications de statut, les votes, les validations de PV ou la génération de documents, sont systématiquement interceptées et enregistrées via ce mécanisme, créant ainsi une piste d'audit exhaustive et fiable. 



**13.3. Fonctionnalité : Gestion du Cycle de Vie et Historisation des Carrières** **13.3.1. Architecture Fonctionnelle **

Le système traite les informations de grade et de fonction du personnel non pas comme des données statiques, mais comme des **données datées**, valables pour une période définie. Cette approche permet de reconstituer avec précision l'organigramme et les responsabilités de l'établissement à n'importe quelle date passée. 

**13.3.2. Implémentation Technique **

Cette historisation est réalisée grâce à des tables de liaison dédiées qui enregistrent chaque changement comme une nouvelle entrée, plutôt que de modifier une entrée existante. 

• **Historisation des Grades :** La table acquerir associe un numero\_enseignant à un id\_grade à partir d'une date\_acquisition spécifique. Chaque promotion ou changement 

de grade se traduit par l'ajout d'une nouvelle ligne, conservant ainsi l'historique complet des grades obtenus. 

• **Historisation des Fonctions :** La table occuper associe un numero\_enseignant à une id\_fonction pour une période délimitée par une date\_debut\_occupation et une date\_fin\_occupation. Une date\_fin\_occupation nulle \(NULL\) signifie que la fonction est actuellement occupée. Mettre fin à une fonction consiste à renseigner cette date de fin, préservant ainsi l'enregistrement de la période de responsabilité. 

Grâce à cette modélisation, le système peut répondre à des requêtes temporelles complexes, comme "Qui était le responsable de la spécialité MIAGE en octobre 2022 ?", en interrogeant simplement les périodes de validité enregistrées dans ces tables. 

**13.4. Conclusion **

Ensemble, la piste d'audit et l'historisation des carrières forment l'épine dorsale de la mémoire institutionnelle de la plateforme "GestionMySoutenance". Elles garantissent non seulement la sécurité et la traçabilité des opérations quotidiennes, mais aussi la cohérence et la pérennité des données administratives sur le long terme, constituant un atout indispensable pour la gouvernance et le pilotage de l'établissement. 



**Section 14 : Conception de l'Outil d'Importation de Données Avancé** **14.1. Introduction et Objectifs **

La gestion efficace des populations étudiantes et enseignantes, particulièrement lors des rentrées académiques, nécessite un outil d'importation de données à la fois puissant, flexible et fiable. Pour répondre à ce besoin critique, la plateforme "Gestion MySoutenance" intègre un module d'importation avancé. 

Cette approche a été préférée à un simple chargeur de fichiers pour sa capacité à gérer de grands volumes de données sans dégrader l'expérience utilisateur et pour sa flexibilité face à des sources de données hétérogènes. Les objectifs de cette conception sont les suivants : 

• **Flexibilité Maximale :** Libérer l'utilisateur de la contrainte d'un modèle de fichier rigide en lui permettant de faire correspondre dynamiquement les colonnes de son fichier aux champs attendus par le système. 

• **Expérience Utilisateur Intuitive :** Offrir un processus guidé, interactif et réactif, qui permet la correction d'erreurs simples directement dans l'interface, minimisant ainsi les allers-retours fastidieux. 

• **Robustesse et Scalabilité :** Garantir un traitement fiable des fichiers de grande taille grâce à une architecture asynchrone, prévenant les échecs liés aux délais d'attente du navigateur ou du serveur. 

• **Intégrité et Traçabilité :** Assurer une importation de données atomique et entièrement auditée, garantissant la cohérence de la base de données. 

**14.2. Architecture Fonctionnelle : Un Processus en Quatre Phases** Le workflow est conçu comme un assistant intelligent qui accompagne l'Administrateur ou le Responsable Scolarité \(RS\) à chaque étape. 

**Phase 1 : Téléversement et Mappage Interactif des Données** Cette première phase vise à comprendre le fichier de l'utilisateur. 

1. **Téléversement Flexible :** L'utilisateur sélectionne le type d'entité à importer \(ex: 

"Étudiants"\) et téléverse son fichier de données \(CSV, Excel\). Aucune structure de colonne n'est imposée à ce stade. 

2. **Interface de Mappage :** Le système analyse uniquement les en-têtes du fichier et présente une interface de mappage. Cette interface affiche deux colonnes : à gauche, les noms des colonnes extraites du fichier de l'utilisateur ; à droite, des menus déroulants contenant les champs requis par la base de données \(ex: "nom", "prenom", 

"email", "id\_niveau\_etude"\). 

3. **Suggestion Intelligente :** Le système tente de pré-remplir le mappage en se basant sur la similarité des noms \(ex: "Courriel" sera automatiquement associé à "email"\). 

L'utilisateur peut ensuite valider ou ajuster manuellement chaque correspondance. 

Cette étape cruciale rend l'outil adaptable à de multiples formats de fichiers sources. 

**Phase 2 : Prévisualisation Dynamique et Correction en Ligne** Une fois le mappage validé, le système traite le fichier en mémoire pour présenter une prévisualisation interactive. 

1. **Grille de Validation :** Les données sont affichées dans un tableau, où chaque ligne est précédée d'une icône de statut \(Valide, Avertissement, Erreur\) déterminée par des règles de validation de format, de référence et de logique métier. 

2. **Correction en Ligne :** Pour les erreurs de format simples \(ex: une date mal formatée, une faute de frappe dans un email\), le champ concerné est directement éditable dans la grille. L'utilisateur peut corriger la valeur, et une re-validation est déclenchée instantanément pour la ligne modifiée, fournissant un retour immédiat. Cette fonctionnalité élimine la nécessité de corriger le fichier source et de le téléverser à nouveau pour des erreurs mineures. 

**Phase 3 : Lancement du Traitement et Gestion Asynchrone** C'est là que la robustesse de l'outil se manifeste pour les gros volumes. 

1. **Soumission en Arrière-plan :** Lorsque l'utilisateur clique sur "Lancer l'Importation", la plateforme ne bloque pas sa navigation. Le système enregistre le fichier et les règles de mappage, puis met la tâche dans une file d'attente de traitement. 

2. **Notification de Prise en Charge :** L'interface affiche immédiatement un message confirmant que le fichier est en cours de traitement et que l'utilisateur sera notifié à sa complétion. Il peut ainsi continuer à travailler sur d'autres tâches. 

3. **Exécution par un Worker :** Un processus serveur indépendant \(worker\) prend en charge la tâche, sans contrainte de temps d'exécution. Il effectue l'importation transactionnelle des données validées et génère un rapport détaillé. 

**Phase 4 : Notification et Rapport d'Opération Final** 

Une fois le traitement en arrière-plan terminé, le système clôt le processus de manière proactive. 

1. **Notification :** Une notification est envoyée à l'utilisateur via la messagerie interne de la plateforme et par courrier électronique. 

2. **Rapport Détaillé :** La notification contient un lien vers une page de rapport qui synthétise le résultat de l'opération : nombre d'enregistrements créés avec succès, nombre d'avertissements et nombre d'échecs. 

3. **Export des Erreurs :** Cette page de rapport propose un lien pour télécharger un fichier contenant uniquement les lignes qui n'ont pas pu être importées, enrichi d'une colonne expliquant la cause précise de chaque erreur. Ce fichier est directement exploitable pour une correction et une nouvelle tentative d'importation. 

**14.3. Conclusion **

Cette approche avancée transforme l'outil d'importation d'un simple chargeur de données en un véritable assistant d'intégration. En privilégiant la flexibilité du mappage, l'interactivité de la correction et la robustesse du traitement asynchrone, "Gestion MySoutenance" se dote d'une fonctionnalité essentielle, capable de s'adapter aux contraintes opérationnelles de l'établissement tout en offrant une expérience utilisateur optimisée, fiable et efficace. 



**Section 15 : Logique de la Checklist de Conformité Traçable** **15.1. Rôle et Objectifs **

Le processus de validation d'un rapport au sein de la plateforme "Gestion MySoutenance" 

débute par une étape administrative fondamentale, pilotée par l'Agent de Contrôle de Conformité. Avant toute évaluation académique du fond, ce dernier a pour mission de réaliser une vérification rigoureuse de la conformité administrative et réglementaire du rapport soumis par l'étudiant. 

L'objectif de cette fonctionnalité est de structurer et de standardiser cette vérification en s'appuyant sur une checklist prédéfinie. Ce mécanisme vise à garantir : 

• **L'Objectivité :** Tous les rapports sont évalués sur la base des mêmes critères standards établis par l'établissement. 

• **La Rigueur :** L'agent est guidé point par point pour n'omettre aucune vérification essentielle. 

• **La Traçabilité :** Chaque décision de conformité, pour chaque critère, est enregistrée, créant une piste d'audit claire. 

• **La Clarté de la Rétroaction :** En cas de non-conformité, le retour fait à l'étudiant est précis, constructif et basé sur les points de la checklist. 

**15.2. Architecture Fonctionnelle et Workflow de Vérification** Le processus est intégré à l'interface de travail de l'Agent de Conformité et se déroule en plusieurs phases séquentielles. 

Phase 1 : Prise en Charge du Rapport 

Lorsqu'un étudiant soumet son rapport, celui-ci apparaît dans le tableau de bord de l'Agent de Conformité comme étant "en attente d'examen". En sélectionnant le rapport, l'agent accède à une interface dédiée qui lui présente le contenu textuel intégral du travail de l'étudiant. 

Phase 2 : Évaluation via la Checklist 

Parallèlement à la consultation du rapport, l'interface affiche une grille de conformité. Cette grille liste l'ensemble des points de contrôle standards que l'agent doit vérifier. Pour chaque critère de la liste \(ex: "Respect de la page de garde", "Présence du résumé", "Bibliographie formatée", "Validité du stage associée"\), l'agent doit statuer en choisissant une option, typiquement "Conforme" ou "Non Conforme". 

Phase 3 : Formalisation de la Décision 

À l'issue de son analyse, l'agent formalise sa décision globale pour le rapport : 

• **Cas 1 : Rapport "Conforme" **. Si tous les critères de la checklist sont validés, l'agent déclare le rapport comme étant "Conforme". Le système automatise alors la transmission du rapport à l'étape suivante : l'évaluation par la commission de validation. 

• **Cas 2 : Rapport "Non Conforme" **. Si un ou plusieurs critères ne sont pas respectés, l'agent doit qualifier le rapport de "Non Conforme". Cette action est conditionnée par une obligation : il doit impérativement rédiger un commentaire précis et constructif. Ce commentaire doit détailler chaque point de non-conformité constaté et expliquer clairement les corrections attendues de la part de l'étudiant. 

Phase 4 : Traçabilité et Boucle de Rétroaction 

La décision finale de l'agent est enregistrée et auditée, garantissant la traçabilité de la vérification. 

Si le rapport a été jugé non-conforme, le système notifie l'étudiant et lui retourne électroniquement son travail. L'étudiant peut alors consulter dans son espace personnel le détail des points de non-conformité et les commentaires de l'agent. Après avoir apporté les corrections nécessaires, il pourra soumettre à nouveau son rapport, qui réintégrera le circuit de validation pour une nouvelle vérification de conformité. 

**15.3. Implémentation et Modélisation **

Le système s'appuie sur une modélisation qui sépare la définition des critères de leur application. Une table de référence contient la liste exhaustive et standardisée de tous les points de contrôle constituant la checklist officielle de l'établissement. Une seconde table de liaison est utilisée pour enregistrer le résultat de chaque vérification pour chaque rapport, associant l'identifiant du rapport, l'identifiant du critère vérifié, et le statut donné par l'agent. 

Cette structure assure la pérennité et la cohérence du processus de vérification dans le temps. 

**15.4. Conclusion **

Cette approche de la checklist de conformité, bien que directe, est une méthode robuste et éprouvée. Elle apporte la structure et la rigueur indispensables à une étape administrative critique du parcours de l'étudiant. En standardisant les critères, en traçant les décisions et en formalisant la communication, elle garantit l'équité de traitement entre les étudiants et l'efficacité du workflow global de validation des rapports. 



**Section 16 : Système Avancé de Génération et de Gestion des Bulletins de Notes** **16.1. Introduction et Objectifs **

La gestion des résultats académiques est au cœur des processus d'un établissement d'enseignement supérieur. Le système de "Gestion MySoutenance" adopte une architecture avancée pour cette fonction, conçue pour répondre simultanément aux exigences de contrôle de l'administration et au besoin d'autonomie et de réactivité des étudiants. 

Cette approche met en place un écosystème où deux types de documents coexistent : le **Bulletin de Notes Officiel**, document formel et certifié, et le **Relevé de Notes Provisoire**, un outil de consultation en libre-service. La conception de ce module vise les objectifs suivants : 

• **Efficacité Administrative :** Doter le Responsable Scolarité d'outils de génération en masse pour optimiser son temps de travail. 

• **Autonomie de l'Étudiant :** Permettre aux étudiants d'accéder à leurs résultats en temps réel, à tout moment, sans solliciter l'administration. 

• **Intégrité et Contrôle :** Garantir l'authenticité et la traçabilité des documents officiels grâce à un processus de génération exclusif et à un système de gestion des versions. 

• **Sécurité de la Diffusion :** Assurer que les documents officiels ne sont accessibles qu'aux destinataires légitimes via un canal sécurisé. 

**16.2. Le Processus du Responsable Scolarité \(RS\) : Efficacité et Contrôle Absolu** Le bulletin officiel, qui engage la responsabilité de l'établissement, reste sous le contrôle exclusif du RS. Le processus est cependant optimisé pour être le plus efficace possible. 

1. **Génération en Masse et Asynchrone :** Pour gérer les fins de semestre, le RS peut lancer la génération des bulletins pour une promotion entière en une seule action. Le système traite cette lourde tâche en arrière-plan, de manière asynchrone, ce qui permet au RS 

de continuer à travailler sans être bloqué. Une notification lui est envoyée lorsque tous les documents ont été générés et distribués. 

2. **Gestion des Versions et Archivage :** Le système intègre une gestion de versions. Si une note doit être corrigée après une première publication, le RS peut régénérer le bulletin. 

Le nouveau document sera estampillé comme la version la plus récente \(ex: v1.1\), tandis que l'ancien sera conservé dans les archives mais clairement marqué comme 

"Remplacé". Cela assure une piste d'audit complète et garantit que seule la dernière version valide est considérée comme officielle. 

3. **Mise à Disposition :** L'acte de génération par le RS déclenche automatiquement la mise à disposition du PDF officiel dans l'espace personnel de chaque étudiant concerné. 

**16.3. L'Expérience Étudiante : Autonomie et Accès Sécurisé** L'étudiant bénéficie d'une double fonctionnalité qui lui offre à la fois information instantanée et accès aux documents officiels. 

1. Le Relevé de Notes Provisoire en Libre-Service : 

À tout moment, via un bouton dédié dans son espace, l'étudiant peut générer instantanément un relevé de ses notes. Ce document est produit en temps réel à partir des données de la base. 

Pour prévenir toute utilisation abusive, il porte systématiquement des marques distinctives claires : un filigrane "PROVISOIRE - DOCUMENT NON OFFICIEL" et la date/heure de sa génération. 

2. Consultation et Téléchargement des Bulletins Officiels : Dans une section distincte de son portail, intitulée "Mes Documents Officiels", l'étudiant accède à la liste de tous les bulletins officiels générés pour lui par l'administration. Pour chaque bulletin, il peut voir la période concernée, la date de publication par le RS et le numéro de version. Un bouton "Télécharger" lui permet de récupérer une copie du fichier PDF officiel et authentique pour ses propres archives ou ses démarches. 

**16.4. Conclusion **

Cette architecture synergique représente la meilleure synthèse possible des besoins de chaque partie. Elle garantit le **contrôle** et la **sécurité** indispensables à l'administration grâce à la génération centralisée et à la gestion des versions des documents officiels. Simultanément, elle offre à l'étudiant **l'autonomie** et la **réactivité** qu'il attend, tout en réduisant la charge administrative. En dissociant le besoin d'information \(le relevé provisoire\) de l'acte de certification \(le bulletin officiel\), le système gagne en efficacité, en clarté et en satisfaction pour tous ses utilisateurs. 



**Section 17 : Mécanismes de Sécurité et de Validation des Comptes** **17.1. Introduction et Objectifs Stratégiques **

La sécurité des accès et la fiabilité des informations de contact sont des piliers fondamentaux pour la confiance et le bon fonctionnement de la plateforme "Gestion MySoutenance". Pour renforcer ces aspects, deux mécanismes complémentaires sont mis en œuvre : un processus de validation des adresses électroniques pour garantir l'acheminement des communications, et un système de blocage de compte temporaire pour prémunir la plateforme contre les tentatives d'accès non autorisées. La mise en place de ces systèmes est cruciale pour maintenir la confiance des utilisateurs et protéger les données de l'établissement. 

**17.2. Fonctionnalité : Validation de l'Adresse Email par Jeton** Ce processus a pour but de confirmer que chaque utilisateur a bien le contrôle de la boîte de réception de l'adresse email associée à son compte. C'est une condition indispensable pour des communications fiables, notamment pour la réinitialisation de mot de passe et l'envoi de notifications importantes. 

**Description Détaillée du Workflow :** 

1. **Déclenchement du Processus :** La validation est requise dès la création d'un compte ou lors d'un changement d'adresse email par l'utilisateur dans son profil personnel. Le statut de l'adresse email est alors positionné sur "non-vérifiée". 

2. **Génération et Stockage du Jeton :** 

o Le système génère un jeton \(token\) cryptographiquement sécurisé, à usage unique, et avec une durée de validité limitée \(par exemple, 24 heures\). 

o Ce jeton est stocké dans la base de données, dans la colonne token\_validation\_email de la table utilisateur. La date d'expiration du jeton est également enregistrée pour permettre la vérification de sa validité temporelle. 

3. **Envoi de l'Email de Confirmation :** 

o Un email est immédiatement et automatiquement envoyé à l'adresse en attente de validation. 

o **Contenu de l'email :** Le message est clair et direct : "Bonjour \[Prénom Nom\], bienvenue sur la plateforme Gestion MySoutenance. Pour finaliser la configuration de votre compte, veuillez cliquer sur le lien ci-dessous pour confirmer que cette adresse email vous appartient. Ce lien de validation expirera dans 24 heures." 

4. **Action de l'Utilisateur et Validation :** 

o L'utilisateur clique sur le lien reçu. Le système reçoit la requête contenant le jeton. 

o Le serveur vérifie que le jeton existe, qu'il correspond à l'utilisateur et qu'il n'a pas expiré. 

o Si toutes les conditions sont remplies, le statut de l'email est changé à "vérifié", et le jeton token\_validation\_email est immédiatement effacé de la base de données pour empêcher toute réutilisation. 

5. **Expérience Utilisateur en cas de non-validation :** Tant que l'adresse n'est pas vérifiée, un bandeau d'information permanent peut être affiché dans l'espace de l'utilisateur, l'invitant à consulter ses emails et lui offrant la possibilité de renvoyer le lien de validation. 

Implémentation Technique : 

La table utilisateur sera enrichie des colonnes suivantes : 

• email\_valide \(BOOLEAN\) : Indique si l'adresse a été confirmée. 

• token\_validation\_email \(VARCHAR\) : Stocke le jeton à usage unique. 

• date\_expiration\_token \(DATETIME\) : Stocke la date et l'heure d'expiration du jeton. 

**17.3. Fonctionnalité : Protection contre les Attaques par Force Brute** Ce mécanisme de sécurité prévient les tentatives de connexion automatisées en verrouillant temporairement un compte après un nombre excessif d'échecs. 

**Description Détaillée du Workflow :** 

1. **Suivi des Tentatives Échouées :** 

o Le système utilise une colonne tentatives\_connexion\_echouees dans la table utilisateur pour compter les échecs de connexion consécutifs. 

o À chaque fois qu'un utilisateur soumet un mot de passe incorrect, ce compteur est incrémenté. 

2. **Réinitialisation en cas de Succès :** Dès qu'une connexion est réussie, le compteur tentatives\_connexion\_echouees est immédiatement remis à 0, considérant que l'accès est légitime. 

3. **Activation du Verrouillage :** 

o Le système compare la valeur du compteur à un seuil défini par l'Administrateur \(par exemple, 5 tentatives\). 

o Lorsque ce seuil est atteint, le mécanisme de blocage se déclenche. 

4. **Processus de Blocage du Compte :** 

o Le système inscrit dans la colonne compte\_bloque\_jusqua la date et l'heure exactes jusqu'auxquelles le compte sera inaccessible \(ex: heure actuelle \+ 15 

minutes\). La durée du blocage est également un paramètre configurable par l'Administrateur. 

o Le compteur tentatives\_connexion\_echouees est remis à 0. 

o **Message à l'utilisateur :** L'interface affiche un message d'erreur explicite et rassurant : "Trop de tentatives de connexion. Pour votre sécurité, l'accès à votre compte a été temporairement suspendu. Veuillez réessayer dans 15 minutes. Si vous avez oublié vos informations, nous vous invitons à utiliser la fonction 'Mot de passe oublié'." 

5. **Période de Verrouillage :** 

o À chaque nouvelle tentative de connexion, le système vérifie en premier lieu le champ compte\_bloque\_jusqua. 

o Si la date et l'heure actuelles sont antérieures à la date de fin du blocage, l'accès est immédiatement refusé, sans même vérifier le mot de passe. 

o Une fois le délai écoulé, le champ compte\_bloque\_jusqua est ignoré et le processus de connexion normal peut reprendre. 

Implémentation Technique : 

La table utilisateur gère cette logique via deux colonnes principales : 

• tentatives\_connexion\_echouees \(TINYINT, default: 0\) : Compteur des échecs consécutifs. 

• compte\_bloque\_jusqua \(DATETIME, nullable\) : Horodatage de fin de la période de blocage. Si NULL, le compte n'est pas bloqué. 



**Section 18 : Gestion de la Délégation et des Transitions de Rôles** **18.1. Introduction et Objectifs **

La continuité des processus métier et la flexibilité organisationnelle sont essentielles au bon fonctionnement de la plateforme "Gestion MySoutenance". Pour répondre aux réalités opérationnelles telles que les absences temporaires ou les évolutions de carrière du personnel, le système intègre des fonctionnalités avancées de délégation de responsabilités et de gestion des transitions de rôles. L'objectif est de s'assurer qu'aucune tâche critique ne reste en suspens, tout en maintenant un haut niveau de sécurité et de traçabilité. 

**18.2. Fonctionnalité : Délégation de Responsabilités Spécifiques** Ce module permet à un utilisateur détenant des responsabilités de les transférer de manière contrôlée, partielle et temporaire à un autre utilisateur. 

**Description Détaillée du Workflow :** 

1. **Initiation de la Délégation :** L'utilisateur souhaitant déléguer ses fonctions \(le délégant\) accède à une interface dédiée dans son espace personnel. Il y initie une nouvelle délégation. 

2. **Configuration de la Délégation :** Un formulaire de configuration lui permet de définir précisément le cadre du mandat : 

o **Bénéficiaire :** Il sélectionne dans une liste d'utilisateurs éligibles la personne à qui il souhaite déléguer ses pouvoirs \(le délégué\). 

o **Tâches Déléguées :** Il ne délègue pas l'intégralité de son rôle, mais choisit des permissions spécifiques dans une liste prédéfinie \(ex: "Présider une session", 

"Valider un rapport de conformité"\). 

o **Périmètre \(Optionnel\) :** La délégation peut être restreinte à un contexte particulier, comme une seule session de validation ou une promotion spécifique. 

o **Durée :** Une date de début et une date de fin sont obligatoires, encadrant précisément la période de validité de la délégation. 

3. **Activation et Exercice de la Délégation :** 

o Une fois la délégation validée, le système accorde temporairement au délégué les droits correspondants. 

o Lorsqu'il agit dans ce cadre, l'interface du délégué peut afficher une notification claire, comme "Vous agissez par délégation de \[Nom du Délégant\]". 

o Chaque action effectuée par le délégué est rigoureusement consignée dans le journal d'audit avec la mention de la délégation, assurant une traçabilité parfaite. 

4. **Fin de la Délégation :** Les permissions additionnelles du délégué sont automatiquement et instantanément révoquées à la date de fin programmée. Le délégant conserve également la possibilité de mettre fin à la délégation de manière anticipée à tout moment. 

**18.3. Fonctionnalité : Procédure de Gestion des Transitions de Rôles** Ce processus encadre les cas de départs ou de changements de fonction d'un utilisateur, afin de garantir que les tâches dont il avait la charge ne deviennent pas orphelines. 

**Description Détaillée du Workflow :** 

1. **Déclenchement par l'Administrateur :** La procédure est initiée par l'Administrateur au moment où il modifie le statut d'un compte utilisateur \(par exemple, en le désactivant ou en changeant son groupe de permissions suite à un changement de poste\). 

2. **Détection Automatique des Tâches en Cours :** Cette action déclenche une analyse par le système, qui identifie toutes les tâches actives et en attente qui étaient spécifiquement assignées à cet utilisateur. Cela peut inclure des votes à donner, des rapports à évaluer, des procès-verbaux à valider, ou des réclamations à traiter. 

3. **Interface de Gestion de la Transition :** L'Administrateur est alors dirigé vers un tableau de bord spécifique qui liste toutes ces "tâches orphelines". 

4. **Réassignation Manuelle et Contrôlée :** Pour chaque tâche de la liste, l'Administrateur doit obligatoirement désigner un remplaçant parmi les utilisateurs éligibles. Par exemple, un rapport en attente de validation de conformité sera réassigné à un autre Agent de Conformité ; un vote manquant dans une commission sera géré en concertation avec le président de session pour nommer un substitut. 

5. **Finalisation et Notification :** Une fois que toutes les tâches ont été réassignées, la transition est considérée comme terminée. Les utilisateurs nouvellement assignés reçoivent une notification les informant de leurs nouvelles responsabilités. L'ensemble de la procédure de réassignation est enregistré dans le journal d'audit pour garantir une transparence totale. 



**Section 19 : Système de Notifications et Gestion des Communications** **19.1. Introduction et Objectifs **

Une communication efficace est essentielle au bon déroulement des processus de la plateforme 

"Gestion MySoutenance". Pour ce faire, le système est doté d'un module de notification configurable et d'une gestion du cycle de vie des communications internes. L'objectif est de s'assurer que les informations pertinentes sont acheminées de manière fiable et opportune, tout en offrant aux utilisateurs un contrôle sur le flux de notifications pour éviter toute surcharge informationnelle. 

**19.2. Fonctionnalité : Catalogue des Événements et Matrice de Diffusion Centralisée** Cette fonctionnalité donne à l'administration un contrôle total et granulaire sur le système de notification. 

**Description Détaillée du Workflow :** 

1. **Catalogue d'Événements :** L'Administrateur du système a accès à un panneau de configuration qui recense tous les événements métier de la plateforme susceptibles de générer une notification. Cette liste inclut des événements tels que "Rapport Soumis", 

"Vote de commission Enregistré", "Décision Finale de la commission Rendue", "Procès-Verbal Disponible", ou "Changement de Statut du Personnel". 

2. **Matrice de Diffusion :** Pour chaque événement de ce catalogue, l'Administrateur configure une matrice de diffusion. Cette interface visuelle lui permet de définir : o **Les Destinataires :** Il sélectionne les rôles qui doivent être notifiés \(par exemple, Étudiant, Agent de Conformité, Président de session, Membre de commission\). 

o **Les Canaux :** Il choisit le ou les canaux de communication à utiliser pour chaque rôle \(par exemple, "Notification interne à la plateforme" et/ou "Courrier électronique"\). 

3. **Gestion Centralisée :** Grâce à cette matrice, l'Administrateur peut, par exemple, décider qu'un "Vote Enregistré" ne génère qu'une notification interne pour le Président de session, tandis qu'une "Décision Finale Rendue" envoie une notification interne et un email à l'étudiant concerné. Cette gestion centralisée garantit une politique de communication cohérente et facilement modifiable. 

**19.3. Fonctionnalité : Préférences de Notification Personnalisables** Tout en maintenant un contrôle central, le système offre aux utilisateurs la flexibilité d'ajuster les notifications à leurs habitudes de travail. 

**Description Détaillée du Workflow :** 

1. **Interface de Préférences :** Chaque utilisateur dispose, dans son espace profil, d'une section dédiée à la gestion de ses préférences de notification. 

2. **Options de Personnalisation :** L'utilisateur peut y définir ses choix. Il peut par exemple : o Demander à recevoir un unique email de résumé quotidien regroupant toutes les notifications non urgentes de la journée, plutôt que de multiples emails instantanés. 

o Désactiver l'envoi par email pour les notifications considérées comme secondaires, sachant qu'elles resteront toujours consultables dans son centre de notification sur la plateforme. 

3. **Protection des Communications Critiques :** Le système définit une liste de notifications jugées "critiques" qui ne peuvent pas être désactivées par l'utilisateur. Celles-ci incluent, par exemple, les alertes de sécurité, les demandes de correction sur un rapport, ou les convocations officielles. Cette règle garantit que les informations les plus importantes sont toujours transmises. 

**19.4. Fonctionnalité : Cycle de Vie et Archivage de la Messagerie Interne** Pour assurer la performance et la clarté de l'outil de messagerie interne, une gestion de son cycle de vie est implémentée. 

**Description Détaillée du Workflow :** 

1. **Archivage Manuel par l'Utilisateur :** Un utilisateur peut à tout moment choisir d'archiver une conversation. L'action retire la conversation de la boîte de réception principale et la déplace vers un dossier "Archives". La conversation n'est pas supprimée et peut être consultée ou réactivée à tout moment. 

2. **Archivage Automatique par le Système :** Une politique d'archivage automatique, configurable par l'Administrateur, peut être activée. Par exemple, toute conversation inactive depuis plus de 12 mois pourrait être automatiquement archivée par le système, permettant de maintenir une base de données active saine et performante. 

3. **Distinction avec la Suppression :** L'archivage est une action réversible qui vise à désencombrer l'interface. La suppression définitive d'une conversation est une opération beaucoup plus rare, soumise à des droits spécifiques et aux politiques de rétention des données de l'établissement. 



**Section 20 : Performance, Robustesse et Supervision Technique** **20.1. Introduction **

Au-delà de ses fonctionnalités métier, la viabilité à long terme de la plateforme "Gestion MySoutenance" repose sur sa capacité à offrir une expérience utilisateur fluide, à gérer les montées en charge et à être maintenue de manière proactive. Cette section décrit l'architecture technique sous-jacente qui garantit la performance, la réactivité et la fiabilité du système, même en période d'activité intense. 

**20.2. Optimisation de la Performance **

1. Tests de Charge : 

Avant tout déploiement majeur et de manière périodique, des tests de charge seront menés pour simuler des conditions d'utilisation extrêmes. L'objectif est d'identifier et de corriger les goulots d'étranglement potentiels \(requêtes de base de données lentes, consommation excessive de mémoire, etc.\). Des scénarios simuleront des centaines ou des milliers d'utilisateurs se connectant simultanément, soumettant leur rapport, et interagissant avec la plateforme, afin de valider sa capacité à maintenir des temps de réponse acceptables. 

2. Stratégie de Mise en Cache \(Caching\) : 

Pour accélérer l'affichage des pages et réduire la charge sur la base de données, une stratégie de mise en cache sera implémentée. Des technologies comme Redis ou Memcached seront utilisées pour stocker temporairement en mémoire les données fréquemment consultées mais rarement modifiées. Cela inclut typiquement : les listes de valeurs des référentiels \(niveaux d'étude, statuts\), les permissions associées aux rôles, ou encore les profils utilisateurs. Ainsi, lors de consultations répétées, ces données sont servies instantanément sans solliciter la base de données. 

**20.3. Gestion des Tâches Asynchrones **

Certaines opérations sont, par nature, longues et coûteuses en ressources. Tenter de les exécuter en temps réel bloquerait l'interface de l'utilisateur et pourrait provoquer des erreurs. 

1. **Système de File d'Attente \(Queue\) :** Toutes les opérations longues sont déléguées à un système de file d'attente. Lorsqu'une telle action est déclenchée \(par exemple, "Générer les bulletins pour une promotion" ou "Envoyer une notification email à 200 étudiants"\), la plateforme ne fait qu'ajouter une "tâche" à cette file d'attente et répond immédiatement à l'utilisateur, qui peut continuer à naviguer. 

2. **Workers Asynchrones :** Des processus serveurs indépendants, appelés "workers", surveillent en permanence cette file d'attente. Dès qu'une nouvelle tâche apparaît, un worker la prend en charge et l'exécute en arrière-plan. Cela garantit que l'expérience utilisateur reste fluide et que les opérations lourdes sont traitées de manière fiable, sans limite de temps. 

**20.4. Supervision \(Monitoring\) et Alerting **

Pour garantir une haute disponibilité, une supervision active de la plateforme est mise en place. 

1. **Monitoring en Temps Réel :** Des outils de supervision seront déployés pour surveiller en continu les indicateurs clés de santé de l'infrastructure et de l'application : charge du processeur \(CPU\), utilisation de la mémoire \(RAM\), temps de réponse de la base de données, taux d'erreurs applicatives \(erreurs 500\), etc. 

2. **Système d'Alerting :** Des seuils critiques seront définis pour ces indicateurs. Si un seuil est dépassé \(par exemple, un taux d'erreur anormalement élevé pendant plus d'une minute\), une alerte automatique est instantanément envoyée à l'équipe technique \(par email, SMS, ou via un canal de messagerie dédié\) pour une intervention immédiate, souvent avant même que les utilisateurs ne soient impactés. 

3. **Centralisation des Logs :** Tous les journaux d'événements et d'erreurs générés par les différentes composantes de l'application sont centralisés dans un système unique. Cela 

permet à l'équipe technique de rechercher, d'analyser et de corréler les informations pour diagnostiquer rapidement et précisément la cause racine de tout incident. 



**Section 21 : Recherche Avancée et Pilotage par les Données** **21.1. Introduction **

Une fois les données collectées et sécurisées, leur véritable valeur réside dans leur exploitation. 

Cette section décrit les fonctionnalités qui permettent de transformer les données brutes de la plateforme en informations actionnables, que ce soit pour des besoins opérationnels via la recherche ou pour le pilotage stratégique via des tableaux de bord. 

**21.2. Fonctionnalité : Recherche Globale Avancée **

Une barre de recherche globale sera mise à la disposition des utilisateurs habilités \(principalement le personnel administratif et les membres de commissions\) pour leur permettre de retrouver rapidement n'importe quelle information au sein de la plateforme. 

1. **Périmètre de Recherche :** La recherche s'étendra à de multiples entités : étudiants \(par nom, matricule\), rapports \(par titre, thème, contenu\), enseignants, sessions de validation, et documents générés \(par leur identifiant unique\). 

2. **Filtrage et Affinage :** Les résultats pourront être affinés grâce à des filtres contextuels puissants, comme la période académique, le statut d'un rapport \(ex: "En correction"\), le niveau d'étude d'un étudiant ou le type de document. 

**21.3. Fonctionnalité : Module de Reporting et Tableaux de Bord** Des tableaux de bord visuels et synthétiques seront développés pour fournir aux instances de direction et de pilotage pédagogique les indicateurs clés de performance \(KPIs\) nécessaires à leurs missions. 

1. **Tableaux de Bord Opérationnels :** Destinés aux administrateurs et responsables de service \(RS, président de commission\), ces tableaux de bord suivront des indicateurs tels que : 

o Le nombre de rapports en attente de validation de conformité. 

o Le temps de traitement moyen d'un rapport par étape \(conformité, évaluation\). 

o La charge de travail des membres de la commission. 

2. **Tableaux de Bord Stratégiques :** Destinés à la direction de l'établissement, ces vues agrégeront les données sur des périodes plus longues pour analyser les tendances : o Taux de réussite des soutenances par promotion et par spécialité. 

o Évolution du nombre de pénalités de retard d'une année sur l'autre. 

o Statistiques sur les thèmes de mémoires les plus fréquents. 

Ces données, présentées sous forme de graphiques et de chiffres clés, constituent un outil précieux d'aide à la décision pour l'amélioration continue des processus pédagogiques et administratifs. 



**Section 23 : Processus de Génération de Documents PDF via un Moteur de Rendu HTML **

**23.1. Introduction et Objectifs **

La production de documents officiels, structurés et à l'apparence professionnelle \(rapports, bulletins, procès-verbaux\) est une fonctionnalité centrale de la plateforme "Gestion MySoutenance". Pour garantir une flexibilité maximale dans la mise en page tout en assurant une maintenance aisée, le système s'appuie sur une approche moderne et robuste : la conversion de documents HTML dynamiquement générés en fichiers PDF. 

L'objectif de cette méthode est de séparer entièrement la logique de récupération des données de la logique de présentation visuelle, permettant ainsi de : 

• Créer des mises en page complexes et riches, fidèles à la charte graphique de l'établissement. 

• Modifier l'apparence des documents générés sans avoir à changer le code applicatif principal. 

• Assembler dynamiquement des informations provenant de sources multiples en un document unique et cohérent. 

**23.2. Architecture Fonctionnelle : Un Processus en Quatre Étapes** Le processus est entièrement orchestré par le serveur de l'application et est transparent pour l'utilisateur final. 

**Étape 1 : Déclenchement et Agrégation des Données** 

L'opération est initiée par une action utilisateur \(ex: clic sur "Télécharger le PDF"\). En réponse, le serveur agit comme un collecteur d'informations et rassemble toutes les données nécessaires depuis la base de données : 

• **Informations sur l'Entité Principale :** Profil de l'étudiant, détails de la session de validation, etc. 

• **Contenu Principal :** L'ensemble des sections textuelles d'un rapport, les notes d'un bulletin, ou les délibérations d'un PV. 

• **Données Relationnelles :** Noms des enseignants, des tuteurs, libellés des matières, etc. 

• **Paramètres Généraux :** Nom de l'établissement, de la formation, année académique en cours. 

**Étape 2 : Construction Dynamique du Document HTML** 

C'est le cœur du processus de mise en page. Le système utilise un **modèle HTML/CSS** prédéfini pour chaque type de document. 

1. **Le Modèle \(Template\) :** Ce fichier, géré par l'Administrateur, n'est pas un simple texte, mais un véritable squelette de page web. Il contient toute la structure visuelle du document final : le logo, les polices de caractères, les couleurs, les en-têtes et pieds de page, la disposition des colonnes, et le style des titres. 

2. **L'Injection des Données :** Le serveur utilise un "moteur de modèles" pour injecter les données collectées à l'étape 1 dans ce modèle HTML. Les informations dynamiques \(comme le nom de l'étudiant ou le contenu d'une section\) remplacent des variables prédéfinies dans le modèle. 

Le résultat de cette étape est un unique et long fichier HTML, invisible pour l'utilisateur, qui contient toutes les informations et qui est stylisé pour ressembler exactement au PDF final. 

**Étape 3 : Rendu et Conversion en PDF** 

La page HTML complète et stylisée est ensuite transmise à une **bibliothèque de rendu PDF**. 

Cette composante logicielle spécialisée agit comme une imprimante virtuelle : 

• Elle lit et interprète la structure HTML et les règles de style CSS. 

• Elle calcule la mise en page, gère les sauts de page pour éviter les coupures disgracieuses, et applique les polices. 

• Elle "dessine" le contenu, page par page, dans un nouveau fichier au format PDF. 

Le produit de cette étape est le document PDF final, non modifiable, qui est une représentation fidèle du document HTML. 

**Étape 4 : Stockage et Diffusion** 

Le fichier PDF nouvellement créé est alors : 

1. Sauvegardé de manière sécurisée sur le serveur de l'application. 

2. Référencé dans la base de données \(par exemple, dans la table document\_genere\) pour la traçabilité. 

3. Présenté à l'utilisateur final pour le téléchargement. 

**23.3. Conclusion **

L'approche de conversion HTML vers PDF est une solution puissante, flexible et maintenable. 

Elle offre un contrôle quasi illimité sur l'apparence des documents produits, tout en garantissant une séparation nette entre les données et leur présentation. Couplée à la gestion des tâches asynchrones pour les documents les plus volumineux, elle constitue l'architecture la plus adaptée pour répondre aux exigences de qualité et de performance de la plateforme "Gestion MySoutenance". 



**Section 24 : Gestion des Cas d'Usage Avancés et des Exceptions de Workflow** **24.1. Introduction **

Pour garantir une couverture fonctionnelle complète, le système doit non seulement gérer les scénarios nominaux, mais aussi les cas d'exception et les variations de processus. Cette section détaille les logiques métier pour trois situations spécifiques : le traitement des rapports 

"Approuvés sous réserve de corrections mineures", la flexibilité du nombre de votants au sein d'une commission, et la gestion des blocages lors de l'approbation des procès-verbaux. 

**24.2. Fonctionnalité : Workflow de Correction Mineure \("Approuvé sous réserve"\)** Ce processus met en place un circuit de validation allégé pour les corrections qui ne justifient pas une nouvelle délibération collégiale. 

**Description Détaillée du Workflow :** 

1. **Déclenchement :** Lorsque la commission rend une décision "Approuvé sous réserve", le statut du rapport est mis à jour vers un état dédié, tel que EN\_CORRECTION\_MINEURE. 

L'étudiant est notifié et son interface de rédaction est déverrouillée, avec un affichage clair des commentaires de la commission. 

2. **Soumission par l'Étudiant :** Après avoir effectué les modifications demandées, l'étudiant utilise une option de soumission spécifique pour ses corrections. Cette action verrouille à nouveau le rapport et change son statut en EN\_VERIFICATION\_CORRECTION. 

3. **Validation Simplifiée :** Une notification est alors envoyée uniquement au Président de la session \(ou au rapporteur désigné\), et non à toute la commission. Celui-ci accède à une interface de validation dédiée où il peut consulter la version corrigée. Il dispose de deux actions : 

o **"Valider les corrections" :** S'il juge les modifications satisfaisantes, il approuve, et le statut du rapport passe définitivement à VALIDÉ, clôturant le processus. 

o **"Retourner à l'étudiant" :** Si les corrections sont insuffisantes, il peut renvoyer le rapport à l'étudiant avec un nouveau commentaire, réinitiant ainsi la phase de correction mineure. 

**24.3. Fonctionnalité : Flexibilité du Nombre de Membres de Commission** Cette modification rend la règle de consensus dynamique, au lieu de la figer à un nombre arbitraire de votants. 

**Description Détaillée de la Logique :** 

1. **Paramètre de Session :** Le nombre de votants requis pour atteindre un consensus n'est plus une valeur fixe dans le code \(ex: 4\), mais un attribut de la session de validation elle-même. 

2. **Calcul Dynamique :** Lors de la création ou du démarrage d'une session, le système compte le nombre de membres effectivement rattachés à cette session et enregistre ce chiffre \(ex: 3, 4, 5...\) comme le "nombre de votants requis" pour cette session spécifique. 

3. **Algorithme Adaptatif :** L'algorithme de vote est adapté pour se baser sur ce paramètre dynamique. Après chaque vote, il vérifie si le nombre de votes enregistrés est égal au 

"nombre de votants requis" de la session. Si c'est le cas, il procède à l'analyse de l'unanimité. Cette approche garantit que les règles de décision s'appliquent toujours correctement à la composition réelle de la commission pour chaque session. 

**24.4. Fonctionnalité : Gestion des Approbations de Procès-Verbal Bloquées** Ce mécanisme introduit un processus d'escalade temporelle pour éviter qu'un approbateur non-répondant ne paralyse la finalisation d'un Procès-Verbal \(PV\). 

**Description Détaillée du Workflow :** 

1. **Déclenchement d'une Échéance :** Lorsqu'un projet de PV est soumis à la validation collégiale, le système définit automatiquement une date limite d'approbation \(par exemple, 7 jours\). 

2. **Rappels Automatiques :** Des notifications de rappel sont envoyées aux membres n'ayant pas encore approuvé à l'approche de cette échéance. 

3. **Escalade au Président :** Si la date limite est dépassée et que des approbations sont toujours manquantes, le système alerte le Président de session et lui débloque des options d'action spécifiques pour ce PV. 

4. **Action de Déblocage :** Le Président, après analyse de la situation, peut utiliser son autorité pour finaliser le processus via l'une des options suivantes, qui sont toutes rigoureusement auditées : 

o **Approbation par Substitution :** Approuver le PV au nom du membre non-répondant, en ajoutant un commentaire obligatoire pour justifier cette action exceptionnelle. 

o **Validation avec Quorum :** Si les règlements de l'établissement le permettent, forcer la validation du PV avec les approbations déjà collectées, en actant l'absence de réponse des autres membres. 

Une fois le consensus atteint par l'une de ces méthodes, le PV est considéré comme finalisé, et le système procède à sa génération en PDF et à sa diffusion. 





**Plan d'Implémentation Exhaustif de la Couche Modèle** **Introduction : Un Blueprint pour l'Implémentation **

Ce document constitue le blueprint technique définitif pour la couche Modèle de l'application "GestionMySoutenance". Il est conçu pour être directement exploité par l'équipe de développement, fournissant une liste exhaustive, fichier par fichier, de toutes les propriétés, fonctionnalités et dépendances requises. La structure est conforme au standard d'autochargement PSR-4 défini dans le fichier composer.json 1 

et présuppose un environnement PHP 8.2. Chaque modèle hérite d'une classe BaseModel générique, qui encapsule la logique d'interaction commune avec la base de données. 



**Table 1: Cartographie Modèle-Table et Responsabilités **

**Fondamentales **

****

Le tableau suivant fournit une vue d'ensemble de la couche de données, agissant comme une carte de référence rapide pour l'architecture de persistance de l'application. 



Classe du Modèle 

Table SQL Correspondante 

Responsabilité Fondamentale 

\(NomClasse.php\) 

Acquerir 

acquerir 

Historise l'obtention d'un 

grade par un enseignant à 

une date donnée, assurant la 

traçabilité de sa carrière. 

Action 

action 

Référentiel sémantique de 

toutes les actions auditables 

dans le système \(ex: 

CONNEXION, 

SOUMISSION\_RAPPORT\). 

Affecter 

affecter 

Lie un enseignant à un 

rapport au sein d'un jury, en 

spécifiant son rôle \(ex: 

Président, Rapporteur\). 

AnneeAcademique 

annee\_academique 

Référentiel des années 

académiques, gérant leurs 

dates et leur statut 

\(active/inactive\). 

Approuver 

approuver 

Enregistre l'acte de 

vérification de conformité 

d'un rapport par un agent 

administratif, incluant son avis 

et ses commentaires. 

Attribuer 

attribuer 

Lie un enseignant à ses 

domaines de spécialité. 

BaseModel 

N/A 

Classe abstraite fournissant 

les fonctionnalités CRUD de 

base à tous les autres 

modèles. 

CompteRendu 

compte\_rendu 

Représente le Procès-Verbal 

\(PV\) de validation, gérant son 

cycle de vie \(rédaction, 

validation, diffusion\). 

ConformiteRapportDetails 

conformite\_rapport\_details 

Enregistre le résultat de la 

vérification de chaque critère 

de la checklist de conformité 

pour un rapport donné. 

Conversation 

conversation 

Représente une conversation 

\(directe ou de groupe\) dans le 

module de messagerie 

interne. 

CritereConformiteRef 

critere\_conformite\_ref 

Référentiel des critères 

standards utilisés dans la 

checklist de conformité des 

rapports. 

DecisionPassageRef 

decision\_passage\_ref 

Référentiel des décisions de 

fin d'année possibles pour un 

étudiant \(ex: Admis, Ajourné\). 

DecisionValidationPvRef 

decision\_validation\_pv\_ref 

Référentiel des décisions 

possibles lors de la validation 

d'un PV \(ex: Approuvé, 

Modification demandée\). 

DecisionVoteRef 

decision\_vote\_ref 

Référentiel des décisions de 

vote possibles pour un 

membre de la commission \(ex: 

Approuvé, Refusé\). 

Delegation 

delegation 

Gère la délégation de 

permissions spécifiques d'un 

utilisateur à un autre pour une 

période définie. 

DocumentGenere 

document\_genere 

Registre de tous les 

documents PDF générés par 

le système \(PV, attestations, 

bul etins\), avec leur version. 

Ecue 

ecue 

Référentiel des Éléments 

Constitutifs d'Unités 

d'Enseignement \(les 

matières\). 

Enregistrer 

enregistrer 

Table centrale de la piste 

d'audit, qui enregistre les 

actions importantes des 

utilisateurs de manière 

détail ée. 

Enseignant 

enseignant 

Contient les informations de 

profil des enseignants, 

distinctes de leur compte 

utilisateur. 

Entreprise 

entreprise 

Référentiel des entreprises où 

les étudiants effectuent leurs 

stages. 

Etudiant 

etudiant 

Contient les informations de 

profil des étudiants, distinctes 

de leur compte utilisateur. 

Evaluer 

evaluer 

Enregistre les notes obtenues 

par les étudiants pour chaque 

matière \(ECUE\) dans une 

année académique. 

FaireStage 

faire\_stage 

Lie un étudiant à une 

entreprise pour un stage, en 

précisant les dates et le 

tuteur. 

Fonction 

fonction 

Référentiel des fonctions 

administratives occupées par 

le personnel \(ex: Chef de 

département\). 

Grade 

grade 

Référentiel des grades 

académiques des enseignants 

\(ex: Professeur, Maître de 

Conférences\). 

GroupeUtilisateur 

groupe\_utilisateur 

Définit les rôles fonctionnels 

\(ex: GRP\_COMMISSION\) pour 

le système de permissions 

\(RBAC\). 

HistoriqueMotDePasse 

historique\_mot\_de\_passe 

Stocke les anciens hachages 

de mots de passe pour 

empêcher leur réutilisation. 

Inscrire 

inscrire 

Enregistre l'inscription 

administrative d'un étudiant à 

un niveau d'étude pour une 

année donnée, incluant le 

statut de paiement. 

LectureMessage 

lecture\_message 

Table technique qui enregistre 

quel utilisateur a lu quel 

message dans une 

conversation. 

MatriceNotificationRegles 

matrice\_notification\_regles 

Configure les règles de 

diffusion des notifications 

\(quel événement notifie quel 

rôle et par quel canal\). 

MessageChat 

message\_chat 

Stocke le contenu de chaque 

message envoyé dans la 

messagerie interne. 

NiveauAccesDonne 

niveau\_acces\_donne 

Référentiel des niveaux 

d'accès aux données \(ex: 

Total, Restreint\) pour le RBAC. 

NiveauEtude 

niveau\_etude 

Référentiel des niveaux 

d'étude \(ex: Master 1, Master 

2 MIAGE\). 

Notification 

notification 

Stocke les modèles et les 

contenus des notifications 

envoyées par le système. 

Occuper 

occuper 

Historise les fonctions 

administratives occupées par 

un enseignant dans le temps. 

ParticipantConversation 

participant\_conversation 

Lie les utilisateurs aux 

conversations de la 

messagerie auxquel es ils 

participent. 

Penalite 

penalite 

Enregistre et suit les pénalités 

appliquées aux étudiants pour 

soumission tardive. 

PersonnelAdministratif 

personnel\_administratif 

Contient les informations de 

profil des membres du 

personnel administratif. 

Pister 

pister 

Table d'audit qui trace 

spécifiquement l'accès d'un 

utilisateur à un traitement 

\(permission\). 

PvSessionRapport 

pv\_session\_rapport 

Lie un PV de type "Session" à 

tous les rapports qui ont été 

traités dans cette session. 

RapportEtudiant 

rapport\_etudiant 

Entité centrale représentant le 

rapport d'un étudiant, gérant 

son contenu, ses 

métadonnées et son cycle de 

vie. 

RapportModele 

rapport\_modele 

Définit un modèle de structure 

de rapport \(ex: sections, 

ordre\) que les étudiants 

peuvent utiliser. 

RapportModeleAssignation 

rapport\_modele\_assignation 

Assigne un modèle de rapport 

à un ou plusieurs niveaux 

d'étude. 

RapportModeleSection 

rapport\_modele\_section 

Définit une section spécifique 

\(titre, contenu par défaut\) au 

sein d'un modèle de rapport. 

Rattacher 

rattacher 

Matrice de permissions du 

RBAC, associant les 

permissions \(traitement\) aux 

rôles \(groupe\_utilisateur\). 

Recevoir 

recevoir 

Lie une notification à un 

utilisateur destinataire et suit 

son état de lecture. 

Reclamation 

reclamation 

Stocke les réclamations 

soumises par les étudiants et 

leur traitement par 

l'administration. 

Rendre 

rendre 

Lie un enseignant à un PV sur 

lequel il a agi \(ex: rédaction, 

approbation\). 

SectionRapport 

section\_rapport 

Stocke le contenu textuel de 

chaque section d'un rapport 

d'étudiant. 

Sequences 

sequences 

Table technique pour la 

génération d'identifiants 

uniques, lisibles et annuels. 

SessionRapport 

session\_rapport 

Table de liaison qui rattache 

les rapports à une session de 

validation spécifique. 

Sessions 

sessions 

Table technique pour stocker 

les données de session PHP 

en base de données \(pour la 

mise à jour des droits en 

temps réel\). 

SessionValidation 

session\_validation 

Représente une session de 

travail de la commission de 

validation, avec ses dates, son 

mode et son statut. 

Specialite 

specialite 

Référentiel des spécialités de 

formation \(ex: MIAGE, Génie 

Logiciel\). 

StatutConformiteRef 

statut\_conformite\_ref 

Référentiel des statuts de la 

vérification de conformité 

\(Conforme, Non Conforme\). 

StatutJury 

statut\_jury 

Référentiel du statut d'un 

enseignant dans une 

commission \(Président, 

Membre, Rapporteur\). 

StatutPaiementRef 

statut\_paiement\_ref 

Référentiel des statuts de 

paiement des frais 

d'inscription. 

StatutPenaliteRef 

statut\_penalite\_ref 

Référentiel des statuts d'une 

pénalité \(Due, Réglée, 

Annulée\). 

StatutPvRef 

statut\_pv\_ref 

Référentiel des statuts d'un 

Procès-Verbal \(En rédaction, 

En validation, Validé\). 

StatutRapportRef 

statut\_rapport\_ref 

Référentiel des statuts d'un 

rapport tout au long de son 

cycle de vie \(Brouil on, 

Soumis, etc.\). 

StatutReclamationRef 

statut\_reclamation\_ref 

Référentiel des statuts d'une 

réclamation \(Reçue, En cours, 

Clôturée\). 

Traitement 

traitement 

Catalogue de toutes les 

permissions granulaires 

possibles dans l'application 

pour le système RBAC. 

TypeDocumentRef 

type\_document\_ref 

Référentiel des types de 

documents que le système 

peut générer \(PV, 

Attestation...\). 

TypeUtilisateur 

type\_utilisateur 

Définit la catégorie générale 

d'un utilisateur \(Étudiant, 

Enseignant, Personnel 

Administratif...\). 

Ue 

ue 

Référentiel des Unités 

d'Enseignement \(les 

regroupements de matières\). 

Utilisateur 

utilisateur 

Entité centrale pour tous les 

comptes, gérant 

l'authentification, la sécurité 

et les accès. 

ValidationPv 

validation\_pv 

Enregistre l'action 

d'approbation d'un PV par 

chaque membre de la 

commission. 

VoteCommission 

vote\_commission 

Enregistre chaque vote 

individuel d'un membre de la 

commission pour un rapport 

donné dans une session. 



**Section 1: La Fondation - BaseModel.php **

****

Cette classe abstraite sert de parent à toutes les autres classes de modèle. El e a pour responsabilité de centraliser la connexion à la base de données et de fournir une interface standard pour les opérations de persistance de base \(CRUD\). Cette approche assure la cohérence de la logique d'accès aux données et respecte le principe DRY \(Don't Repeat Yourself\). 



**BaseModel.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use PDO; 



● **Définition de la Classe** 

PHP 

abstract class BaseModel 



● **Propriétés **

○ protected static?PDO $pdo = nul ; 

● **Fonctionnalités \(Méthodes\) **

○ public static function setPdo\(PDO $pdoInstance\): void : Méthode statique pour injecter la connexion PDO unique à la classe de base. 

○ public static function find\(string $id\):?static : Recherche et retourne une instance du modèle par sa clé primaire. 

○ public static function findBy\(array $criteria,?array $orderBy = nul ,?int $limit = 

nul ,?int $offset = nul \): array : Recherche et retourne un tableau d'instances du modèle correspondant à des critères. 

○ public static function findAl \(?array $orderBy = nul \): array : Récupère tous les enregistrements de la table pour le modèle. 

○ public static function findOneBy\(array $criteria,?array $orderBy = nul \):?static 

: Recherche et retourne la première instance du modèle correspondant à des critères. 

○ public function save\(\): bool : Insère \(si nouvel e instance\) ou met à jour \(si instance existante\) l'enregistrement correspondant en base de données. 

○ public function delete\(\): bool : Supprime l'enregistrement correspondant en base de données. 

○ public static function countBy\(array $criteria\): int : Compte le nombre d'enregistrements correspondant à des critères. 

○ protected abstract static function getTableName\(\): string : Méthode abstraite que chaque classe enfant doit implémenter pour retourner le nom de sa table SQL. 

○ protected static function executeQuery\(string $sql, array $params =\): 

\\PDOStatement : Méthode utilitaire protégée pour exécuter des requêtes préparées. 

○ protected static function hydrate\(array $data\): static : Méthode protégée pour créer une instance de modèle à partir d'un tableau de données. 



**Section 2: Plan d'Implémentation Alphabétique des Modèles** **\(A-Z\) **

****

Cette section constitue le cœur du document, détail ant la structure de chaque fichier de modèle. 



**Acquerir.php **

****

Ce modèle représente une entrée dans l'historique de carrière d'un enseignant, liant un grade à une date d'acquisition spécifique. Il matérialise la capacité du système à tracer les évolutions de carrière, une exigence clé pour l'audit et la gestion temporel e des responsabilités.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Enseignant; 

use App\\Backend\\Model\\Grade; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Acquerir extends BaseModel 



● **Propriétés **

○ private string $id\_grade; 

○ private string $numero\_enseignant; 

○ private DateTime $date\_acquisition; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdGrade\(\), setIdGrade\(string $id\_grade\), getNumeroEnseignant\(\), setNumeroEnseignant\(string $numero\_enseignant\), getDateAcquisition\(\), setDateAcquisition\(DateTime $date\_acquisition\) 

○ **Méthodes de Relation** : 

■ public function getEnseignant\(\):?Enseignant 

■ public function getGrade\(\):?Grade 

○ **Logique Métier** : 

■ public static function findHistoriquePourEnseignant\(string 

$numero\_enseignant\): array 

■ public static function findGradeActuelPourEnseignant\(string $numero\_enseignant\):?self 



**Action.php **

****

Ce modèle est un référentiel sémantique qui catalogue toutes les actions auditables possibles. Il permet de structurer la piste d'audit \(enregistrer\) de manière normalisée et performante, en utilisant des clés étrangères plutôt que des chaînes de caractères descriptives.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class Action extends BaseModel 



● **Propriétés **

○ private string $id\_action; 

○ private string $libel e\_action; 

○ private?string $categorie\_action; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdAction\(\), setIdAction\(string $id\_action\), getLibel eAction\(\), setLibel eAction\(string $libel e\_action\), getCategorieAction\(\), setCategorieAction\(?string $categorie\_action\) 

○ **Méthodes de Relation** : 

■ public function getEnregistrements\(\): array 



**Affecter.php **

****

Ce modèle lie un enseignant à un rapport d'étudiant pour une session de jury, en précisant son statut \(Directeur de mémoire, Président, etc.\). Il est essentiel pour la composition des commissions et la désignation formel e de l'encadrement.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Enseignant; 

use App\\Backend\\Model\\RapportEtudiant; 

use App\\Backend\\Model\\StatutJury; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Affecter extends BaseModel 



● **Propriétés **

○ private string $numero\_enseignant; 

○ private string $id\_rapport\_etudiant; 

○ private string $id\_statut\_jury; 

○ private bool $directeur\_memoire; 

○ private DateTime $date\_affectation; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getNumeroEnseignant\(\), setNumeroEnseignant\(string $numero\_enseignant\), getIdRapportEtudiant\(\), setIdRapportEtudiant\(string $id\_rapport\_etudiant\), getIdStatutJury\(\), setIdStatutJury\(string $id\_statut\_jury\), isDirecteurMemoire\(\), setDirecteurMemoire\(bool $directeur\_memoire\), getDateAffectation\(\), setDateAffectation\(DateTime $date\_affectation\) 

○ **Méthodes de Relation** : 

■ public function getEnseignant\(\):?Enseignant 

■ public function getRapportEtudiant\(\):?RapportEtudiant 

■ public function getStatutJury\(\):?StatutJury 



**AnneeAcademique.php **

****

Ce modèle gère le référentiel des années académiques. La notion d'année active est fondamentale car el e conditionne de nombreuses opérations et permet une historisation précise des données.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class AnneeAcademique extends BaseModel 



● **Propriétés **

○ private string $id\_annee\_academique; 

○ private string $libel e\_annee\_academique; 

○ private?DateTime $date\_debut; 

○ private?DateTime $date\_fin; 

○ private bool $est\_active; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdAnneeAcademique\(\), setIdAnneeAcademique\(string $id\_annee\_academique\), getLibel eAnneeAcademique\(\), 

setLibel eAnneeAcademique\(string $libel e\_annee\_academique\), getDateDebut\(\), setDateDebut\(?DateTime $date\_debut\), getDateFin\(\), setDateFin\(?DateTime $date\_fin\), isEstActive\(\), setEstActive\(bool $est\_active\) 

○ **Logique Métier** : 

■ public static function findActive\(\):?self 

■ public function activer\(\): void 

■ public function desactiver\(\): void 



**Approuver.php **

****

Ce modèle enregistre l'acte de vérification de conformité d'un rapport par un agent 

administratif. Il stocke la décision \(conforme/non conforme\) et le commentaire associé, qui est crucial pour la boucle de rétroaction avec l'étudiant.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\PersonnelAdministratif; 

use App\\Backend\\Model\\RapportEtudiant; 

use App\\Backend\\Model\\StatutConformiteRef; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Approuver extends BaseModel 



● **Propriétés **

○ private string $numero\_personnel\_administratif; 

○ private string $id\_rapport\_etudiant; 

○ private string $id\_statut\_conformite; 

○ private?string $commentaire\_conformite; 

○ private DateTime $date\_verification\_conformite; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getNumeroPersonnelAdministratif\(\), 

setNumeroPersonnelAdministratif\(string $numero\_personnel\_administratif\), getIdRapportEtudiant\(\), setIdRapportEtudiant\(string $id\_rapport\_etudiant\), getIdStatutConformite\(\), setIdStatutConformite\(string $id\_statut\_conformite\), getCommentaireConformite\(\), setCommentaireConformite\(?string $commentaire\_conformite\), getDateVerificationConformite\(\), setDateVerificationConformite\(DateTime $date\_verification\_conformite\) 

○ **Méthodes de Relation** : 

■ public function getPersonnelAdministratif\(\):?PersonnelAdministratif 

■ public function getRapportEtudiant\(\):?RapportEtudiant 

■ public function getStatutConformite\(\):?StatutConformiteRef **Attribuer.php **

****

Modèle de liaison simple \(M:N\) qui associe un enseignant à ses spécialités. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Enseignant; 

use App\\Backend\\Model\\Specialite; 



● **Définition de la Classe** 

PHP 

class Attribuer extends BaseModel 



● **Propriétés **

○ private string $numero\_enseignant; 

○ private string $id\_specialite; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getNumeroEnseignant\(\), setNumeroEnseignant\(string $numero\_enseignant\), getIdSpecialite\(\), setIdSpecialite\(string $id\_specialite\) 

○ **Méthodes de Relation** : 

■ public function getEnseignant\(\):?Enseignant 

■ public function getSpecialite\(\):?Specialite 



**CompteRendu.php **

****

Ce modèle représente le Procès-Verbal \(PV\) de validation. Il est au cœur du processus de formalisation des décisions de la commission, gérant son type \(individuel ou de session\), son statut \(brouil on, en validation, validé\), son rédacteur, et sa date limite d'approbation.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\RapportEtudiant; 

use App\\Backend\\Model\\StatutPvRef; 

use App\\Backend\\Model\\Utilisateur; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class CompteRendu extends BaseModel 



● **Propriétés **

○ private string $id\_compte\_rendu; 

○ private?string $id\_rapport\_etudiant; 

○ private string $type\_pv; // enum\('Individuel','Session'\) 

○ private string $libel e\_compte\_rendu; 

○ private DateTime $date\_creation\_pv; 

○ private string $id\_statut\_pv; 

○ private?string $id\_redacteur; 

○ private?DateTime $date\_limite\_approbation; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getRapportEtudiant\(\):?RapportEtudiant 

■ public function getStatutPv\(\):?StatutPvRef 

■ public function getRedacteur\(\):?Utilisateur 

■ public function getValidations\(\): array // Récupère les objets ValidationPv 

■ public function getRapportsDeSession\(\): array // Récupère les objets RapportEtudiant via PvSessionRapport 

○ **Logique Métier** : 

■ public function soumettrePourValidation\(\): void 

■ public function verifierConsensusApprobation\(\): bool 

■ public function finaliserEtValider\(\): void 

■ public function isDelaiApprobationDepasse\(\): bool 

■ public function transfererRedaction\(string $id\_nouveau\_redacteur\): void **ConformiteRapportDetails.php **

****

Ce modèle est essentiel pour la traçabilité de la checklist de conformité. Il enregistre, pour un rapport donné, la décision \(Conforme/Non Conforme\) pour chaque critère spécifique de la checklist, tel que décrit dans la logique de la Section 15.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\RapportEtudiant; 

use App\\Backend\\Model\\CritereConformiteRef; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class ConformiteRapportDetails extends BaseModel 



● **Propriétés **

○ private string $id\_conformite\_detail; 

○ private string $id\_rapport\_etudiant; 

○ private string $id\_critere; 

○ private string $statut\_validation; // enum\('Conforme','Non Conforme','Non Applicable'\) 

○ private?string $commentaire; 

○ private DateTime $date\_verification; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getRapportEtudiant\(\):?RapportEtudiant 

■ public function getCritere\(\):?CritereConformiteRef 



**Conversation.php **

****

Modèle central de la messagerie interne, représentant un fil de discussion, qu'il soit 

direct \(entre deux utilisateurs\) ou de groupe.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Conversation extends BaseModel 



● **Propriétés **

○ private string $id\_conversation; 

○ private?string $nom\_conversation; 

○ private DateTime $date\_creation\_conv; 

○ private string $type\_conversation; // enum\('Direct','Groupe'\) 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getParticipants\(\): array // Récupère les objets Utilisateur via ParticipantConversation 

■ public function getMessages\(\): array // Récupère les objets MessageChat 

■ public function getDernierMessage\(\):?MessageChat 

○ **Logique Métier** : 

■ public function ajouterParticipant\(string $numero\_utilisateur\): void 

■ public function retirerParticipant\(string $numero\_utilisateur\): void 

■ public function archiverPourUtilisateur\(string $numero\_utilisateur\): void **CritereConformiteRef.php **

****

Modèle de référentiel qui définit chaque item de la checklist de conformité. 

L'administrateur gère cette liste pour standardiser le processus de vérification administrative des rapports.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class CritereConformiteRef extends BaseModel 



● **Propriétés **

○ private string $id\_critere; 

○ private string $libel e\_critere; 

○ private?string $description; 

○ private bool $est\_actif; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Logique Métier** : 

■ public static function findAl Actifs\(\): array 



**DecisionPassageRef.php **

****

Référentiel des décisions de passage en fin d'année \(Admis, Ajourné, etc.\) que le Responsable Scolarité peut enregistrer pour un étudiant.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class DecisionPassageRef extends BaseModel 



● **Propriétés **

○ private string $id\_decision\_passage; 

○ private string $libel e\_decision\_passage; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdDecisionPassage\(\), setIdDecisionPassage\(string $id\), getLibel eDecisionPassage\(\), setLibel eDecisionPassage\(string $libel e\) **DecisionValidationPvRef.php **

****

Référentiel des décisions qu'un membre de commission peut prendre lors de l'approbation d'un PV \(Approuvé, Modification demandée\).1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class DecisionValidationPvRef extends BaseModel 



● **Propriétés **

○ private string $id\_decision\_validation\_pv; 

○ private string $libel e\_decision\_validation\_pv; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdDecisionValidationPv\(\), setIdDecisionValidationPv\(string $id\), getLibel eDecisionValidationPv\(\), setLibel eDecisionValidationPv\(string $libel e\) 



**DecisionVoteRef.php **

****

Référentiel des décisions possibles lors du vote d'un membre de la commission sur un rapport \(Approuvé, Refusé, Approuvé sous réserve, etc.\).1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class DecisionVoteRef extends BaseModel 



● **Propriétés **

○ private string $id\_decision\_vote; 

○ private string $libel e\_decision\_vote; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdDecisionVote\(\), setIdDecisionVote\(string $id\), getLibel eDecisionVote\(\), setLibel eDecisionVote\(string $libel e\) **Delegation.php **

****

Ce modèle matérialise une délégation de pouvoir. Il enregistre qui délègue \(délégant\), à qui \(délégué\), quel e permission spécifique \(id\_traitement\), et pour quel e durée. 

C'est le cœur technique de la fonctionnalité de délégation décrite dans la Section 18.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Utilisateur; 

use App\\Backend\\Model\\Traitement; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Delegation extends BaseModel 



● **Propriétés **

○ private string $id\_delegation; 

○ private string $id\_delegant; 

○ private string $id\_delegue; 

○ private string $id\_traitement; 

○ private DateTime $date\_debut; 

○ private DateTime $date\_fin; 

○ private string $statut; // enum\('Active','Inactive','Révoquée'\) 

○ private?string $contexte\_id; 

○ private?string $contexte\_type; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getDelegant\(\):?Utilisateur 

■ public function getDelegue\(\):?Utilisateur 

■ public function getTraitement\(\):?Traitement 

○ **Logique Métier** : 

■ public function isEnCours\(\): bool 

■ public function revoquer\(\): void 

■ public static function findDelegationsActivesPourUtilisateur\(string $numero\_utilisateur\): array 



**DocumentGenere.php **

****

Ce modèle agit comme un registre central pour tous les fichiers PDF générés par le système \(PV, attestations, bul etins\). Il assure la traçabilité en liant chaque document à l'entité qu'il concerne et en gérant sa version.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\TypeDocumentRef; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class DocumentGenere extends BaseModel 



● **Propriétés **

○ private string $id\_document; 

○ private string $id\_type\_document; 

○ private string $chemin\_fichier; 

○ private DateTime $date\_generation; 

○ private int $version; 

○ private string $id\_entite\_concernee; 

○ private string $type\_entite\_concernee; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getTypeDocument\(\):?TypeDocumentRef 

■ public function getEntiteConcernee\(\): mixed // Méthode polymorphique 

○ **Logique Métier** : 

■ public function marquerCommeRemplace\(\): void 



**Ecue.php **

****

Référentiel des Éléments Constitutifs d'Unités d'Enseignement \(les matières\), liés à une Unité d'Enseignement \(UE\) parente.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Ue; 



● **Définition de la Classe** 

PHP 

class Ecue extends BaseModel 



● **Propriétés **

○ private string $id\_ecue; 

○ private string $libel e\_ecue; 

○ private string $id\_ue; 

○ private?int $credits\_ecue; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getUe\(\):?Ue 



**Enregistrer.php **

****

Modèle central de la piste d'audit. Chaque instance représente une action significative effectuée par un utilisateur, répondant aux questions "Qui, quoi, quand, sur quoi, et comment?". Le champ details\_action \(JSON\) est particulièrement puissant pour stocker des données contextuel es riches, comme la note explicative d'une correction.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Utilisateur; 

use App\\Backend\\Model\\Action; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Enregistrer extends BaseModel 



● **Propriétés **

○ private string $id\_enregistrement; 

○ private string $numero\_utilisateur; 

○ private string $id\_action; 

○ private DateTime $date\_action; 

○ private?string $adresse\_ip; 

○ private?string $user\_agent; 

○ private?string $id\_entite\_concernee; 

○ private?string $type\_entite\_concernee; 

○ private?string $details\_action; // JSON 

○ private?string $session\_id\_utilisateur; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getUtilisateur\(\):?Utilisateur 

■ public function getAction\(\):?Action 

■ public function getEntiteConcernee\(\): mixed // Méthode polymorphique 

○ **Logique Métier** : 

■ public function getDetailsActionAsArray\(\): array 



**Enseignant.php **

****

Ce modèle contient les informations de profil d'un enseignant \(nom, contact, etc.\), qui sont distinctes de son compte d'authentification \(Utilisateur\). Il est le point d'ancrage pour sa carrière \(grades, fonctions\) et ses spécialités.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Utilisateur; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Enseignant extends BaseModel 



● **Propriétés **

○ private string $numero\_enseignant; 

○ private string $nom; 

○ private string $prenom; 

○ private?string $telephone\_professionnel; 

○ private?string $email\_professionnel; 

○ private string $numero\_utilisateur; 

○ private?DateTime $date\_naissance; 

○ private?string $lieu\_naissance; 

○ private?string $pays\_naissance; 

○ private?string $nationalite; 

○ private?string $sexe; 

○ private?string $adresse\_postale; 

○ private?string $vil e; 

○ private?string $code\_postal; 

○ private?string $telephone\_personnel; 

○ private?string $email\_personnel\_secondaire; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getUtilisateur\(\):?Utilisateur 

■ public function getGradesHistorique\(\): array // Récupère les objets Acquerir 

■ public function getGradeActuel\(\):?Grade 

■ public function getFonctionsHistorique\(\): array // Récupère les objets Occuper 

■ public function getFonctionActuel e\(\):?Fonction 

■ public function getSpecialites\(\): array // Récupère les objets Specialite via Attribuer 

○ **Logique Métier** : 

■ public function getNomComplet\(\): string 



**Entreprise.php **

****

Référentiel des entreprises où les étudiants peuvent effectuer leur stage. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class Entreprise extends BaseModel 



● **Propriétés **

○ private string $id\_entreprise; 

○ private string $libel e\_entreprise; 

○ private?string $secteur\_activite; 

○ private?string $adresse\_entreprise; 

○ private?string $contact\_nom; 

○ private?string $contact\_email; 

○ private?string $contact\_telephone; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getStages\(\): array // Récupère les objets FaireStage **Etudiant.php **

****

Ce modèle contient les informations de profil d'un étudiant. Comme pour l'enseignant, il est découplé du modèle Utilisateur. Il est le point de départ pour accéder à tout le parcours de l'étudiant : inscriptions, stages, rapports, notes, etc.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Utilisateur; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Etudiant extends BaseModel 



● **Propriétés **

○ private string $numero\_carte\_etudiant; 

○ private string $nom; 

○ private string $prenom; 

○ private?DateTime $date\_naissance; 

○ private?string $lieu\_naissance; 

○ private?string $pays\_naissance; 

○ private?string $nationalite; 

○ private?string $sexe; 

○ private?string $adresse\_postale; 

○ private?string $vil e; 

○ private?string $code\_postal; 

○ private?string $telephone; 

○ private?string $email\_contact\_secondaire; 

○ private string $numero\_utilisateur; 

○ private?string $contact\_urgence\_nom; 

○ private?string $contact\_urgence\_telephone; 

○ private?string $contact\_urgence\_relation; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getUtilisateur\(\):?Utilisateur 

■ public function getInscriptions\(\): array // Récupère les objets Inscrire 

■ public function getInscriptionActuel e\(\):?Inscrire 

■ public function getRapports\(\): array // Récupère les objets RapportEtudiant 

■ public function getStages\(\): array // Récupère les objets FaireStage 

■ public function getNotes\(\): array // Récupère les objets Evaluer 

■ public function getPenalites\(\): array // Récupère les objets Penalite 

○ **Logique Métier** : 

■ public function getNomComplet\(\): string 

■ public function aPenaliteEnCours\(\): bool 



**Evaluer.php **

****

Ce modèle enregistre la note obtenue par un étudiant pour une matière \(ECUE\) donnée, dans une année académique spécifique. C'est la brique de base pour la génération des bul etins de notes.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Etudiant; 

use App\\Backend\\Model\\Ecue; 

use App\\Backend\\Model\\AnneeAcademique; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Evaluer extends BaseModel 



● **Propriétés **

○ private string $numero\_carte\_etudiant; 

○ private string $id\_ecue; 

○ private string $id\_annee\_academique; 

○ private DateTime $date\_evaluation; 

○ private?float $note; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getEtudiant\(\):?Etudiant 

■ public function getEcue\(\):?Ecue 

■ public function getAnneeAcademique\(\):?AnneeAcademique 



**FaireStage.php **

****

Modèle de liaison qui formalise le stage d'un étudiant dans une entreprise, avec ses dates, son sujet et son tuteur. La validation de ce stage est un prérequis à la soumission du rapport.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Entreprise; 

use App\\Backend\\Model\\Etudiant; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class FaireStage extends BaseModel 



● **Propriétés **

○ private string $id\_entreprise; 

○ private string $numero\_carte\_etudiant; 

○ private DateTime $date\_debut\_stage; 

○ private?DateTime $date\_fin\_stage; 

○ private?string $sujet\_stage; 

○ private?string $nom\_tuteur\_entreprise; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getEntreprise\(\):?Entreprise 

■ public function getEtudiant\(\):?Etudiant 



**Fonction.php **

****

Référentiel des fonctions administratives que peut occuper un enseignant \(ex: Responsable de spécialité\).1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class Fonction extends BaseModel 



● **Propriétés **

○ private string $id\_fonction; 

○ private string $libel e\_fonction; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdFonction\(\), setIdFonction\(string $id\), getLibel eFonction\(\), setLibel eFonction\(string $libel e\) 



**Grade.php **

****

Référentiel des grades académiques des enseignants \(ex: Professeur, Maître de Conférences\).1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class Grade extends BaseModel 



● **Propriétés **

○ private string $id\_grade; 

○ private string $libel e\_grade; 

○ private?string $abreviation\_grade; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 



**GroupeUtilisateur.php **

****

Modèle clé du système RBAC, définissant les rôles fonctionnels \(Administrateur, Commission, Scolarité, etc.\). Les permissions sont attribuées à ces groupes, et non directement aux utilisateurs.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class GroupeUtilisateur extends BaseModel 



● **Propriétés **

○ private string $id\_groupe\_utilisateur; 

○ private string $libel e\_groupe\_utilisateur; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdGroupeUtilisateur\(\), setIdGroupeUtilisateur\(string $id\), getLibel eGroupeUtilisateur\(\), setLibel eGroupeUtilisateur\(string $libel e\) 

○ **Méthodes de Relation** : 

■ public function getUtilisateurs\(\): array 

■ public function getTraitements\(\): array // Récupère les objets Traitement via Rattacher 



**HistoriqueMotDePasse.php **

****

Ce modèle stocke les anciens hachages de mot de passe d'un utilisateur pour mettre en œuvre une politique de sécurité empêchant la réutilisation de mots de passe récents. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Utilisateur; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class HistoriqueMotDePasse extends BaseModel 



● **Propriétés **

○ private string $id\_historique\_mdp; 

○ private string $numero\_utilisateur; 

○ private string $mot\_de\_passe\_hache; 

○ private DateTime $date\_changement; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getUtilisateur\(\):?Utilisateur 

○ **Logique Métier** : 

■ public static function checkPasswordAgainstHistory\(string $numero\_utilisateur, string $new\_password\_hash, int $history\_limit\): bool **Inscrire.php **

****

Modèle central du parcours administratif de l'étudiant. Il formalise une inscription pour une année et un niveau d'étude, et surtout, il suit le statut du paiement, qui est un prérequis à l'activation du compte.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Etudiant; 

use App\\Backend\\Model\\NiveauEtude; 

use App\\Backend\\Model\\AnneeAcademique; 

use App\\Backend\\Model\\StatutPaiementRef; 

use App\\Backend\\Model\\DecisionPassageRef; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Inscrire extends BaseModel 



● **Propriétés **

○ private string $numero\_carte\_etudiant; 

○ private string $id\_niveau\_etude; 

○ private string $id\_annee\_academique; 

○ private float $montant\_inscription; 

○ private DateTime $date\_inscription; 

○ private string $id\_statut\_paiement; 

○ private?DateTime $date\_paiement; 

○ private?string $numero\_recu\_paiement; 

○ private?string $id\_decision\_passage; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getEtudiant\(\):?Etudiant 

■ public function getNiveauEtude\(\):?NiveauEtude 

■ public function getAnneeAcademique\(\):?AnneeAcademique 

■ public function getStatutPaiement\(\):?StatutPaiementRef 

■ public function getDecisionPassage\(\):?DecisionPassageRef 

○ **Logique Métier** : 

■ public function isPaye\(\): bool 

■ public function validerPaiement\(string $numero\_recu\): void **LectureMessage.php **

****

Table technique de la messagerie qui enregistre la date à laquel e un utilisateur a lu un message spécifique, permettant d'implémenter les indicateurs "lu/non lu". 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\MessageChat; 

use App\\Backend\\Model\\Utilisateur; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class LectureMessage extends BaseModel 



● **Propriétés **

○ private string $id\_message\_chat; 

○ private string $numero\_utilisateur; 

○ private DateTime $date\_lecture; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getMessageChat\(\):?MessageChat 

■ public function getUtilisateur\(\):?Utilisateur 



**MatriceNotificationRegles.php **

****

Ce modèle représente une règle dans la matrice de diffusion des notifications. Il permet à l'administrateur de définir, pour un événement donné, quel groupe d'utilisateurs doit être notifié et par quel canal \(interne, email, ou les deux\), comme décrit dans la Section 19.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Action; 

use App\\Backend\\Model\\GroupeUtilisateur; 



● **Définition de la Classe** 

PHP 

class MatriceNotificationRegles extends BaseModel 



● **Propriétés **

○ private string $id\_regle; 

○ private string $id\_action\_declencheur; 

○ private string $id\_groupe\_destinataire; 

○ private string $canal\_notification; // enum\('Interne','Email','Tous'\) 

○ private bool $est\_active; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getActionDeclencheur\(\):?Action 

■ public function getGroupeDestinataire\(\):?GroupeUtilisateur 

○ **Logique Métier** : 

■ public static function findReglesPourAction\(string $id\_action\): array **MessageChat.php **

****

Modèle représentant un message unique au sein d'une conversation de la messagerie interne. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Conversation; 

use App\\Backend\\Model\\Utilisateur; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class MessageChat extends BaseModel 



● **Propriétés **

○ private string $id\_message\_chat; 

○ private string $id\_conversation; 

○ private string $numero\_utilisateur\_expediteur; 

○ private string $contenu\_message; 

○ private DateTime $date\_envoi; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getConversation\(\):?Conversation 

■ public function getExpediteur\(\):?Utilisateur 

■ public function getLectures\(\): array // Récupère les objets LectureMessage 



**NiveauAccesDonne.php **

****

Référentiel du système RBAC, définissant les niveaux de visibilité sur les données \(ex: Total, Restreint à sa spécialité\).1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class NiveauAccesDonne extends BaseModel 



● **Propriétés **

○ private string $id\_niveau\_acces\_donne; 

○ private string $libel e\_niveau\_acces\_donne; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdNiveauAccesDonne\(\), setIdNiveauAccesDonne\(string $id\), 

getLibel eNiveauAccesDonne\(\), setLibel eNiveauAccesDonne\(string $libel e\) **NiveauEtude.php **

****

Référentiel des niveaux d'étude proposés par l'établissement \(ex: Master 1, Master 2 

MIAGE\). 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class NiveauEtude extends BaseModel 



● **Propriétés **

○ private string $id\_niveau\_etude; 

○ private string $libel e\_niveau\_etude; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdNiveauEtude\(\), setIdNiveauEtude\(string $id\), getLibel eNiveauEtude\(\), setLibel eNiveauEtude\(string $libel e\) 

○ **Méthodes de Relation** : 

■ public function getModelesRapportAssignes\(\): array // Récupère les objets RapportModele via RapportModeleAssignation 



**Notification.php **

****

Ce modèle représente le contenu d'une notification. Il est utilisé par le système pour envoyer des messages aux utilisateurs via différents canaux.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class Notification extends BaseModel 



● **Propriétés **

○ private string $id\_notification; 

○ private string $libel e\_notification; // Devrait probablement contenir le contenu/template 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdNotification\(\), setIdNotification\(string $id\), getLibel eNotification\(\), setLibel eNotification\(string $libel e\) **Occuper.php **

****

Similaire à Acquerir, ce modèle historise l'occupation d'une fonction administrative par un enseignant sur une période donnée \(avec une date de début et de fin\). Il est essentiel pour reconstituer l'organigramme à une date passée.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Fonction; 

use App\\Backend\\Model\\Enseignant; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Occuper extends BaseModel 



● **Propriétés **

○ private string $id\_fonction; 

○ private string $numero\_enseignant; 

○ private DateTime $date\_debut\_occupation; 

○ private?DateTime $date\_fin\_occupation; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getFonction\(\):?Fonction 

■ public function getEnseignant\(\):?Enseignant 

○ **Logique Métier** : 

■ public function isEnCours\(\): bool 

■ public function terminerOccupation\(\): void 



**ParticipantConversation.php **

****

Modèle de liaison \(M:N\) qui associe les utilisateurs aux conversations de la messagerie interne. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Conversation; 

use App\\Backend\\Model\\Utilisateur; 



● **Définition de la Classe** 

PHP 

class ParticipantConversation extends BaseModel 



● **Propriétés **

○ private string $id\_conversation; 

○ private string $numero\_utilisateur; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdConversation\(\), setIdConversation\(string $id\), getNumeroUtilisateur\(\), setNumeroUtilisateur\(string $numero\) 

○ **Méthodes de Relation** : 

■ public function getConversation\(\):?Conversation 

■ public function getUtilisateur\(\):?Utilisateur 



**Penalite.php **

****

Ce modèle enregistre une pénalité \(financière ou administrative\) appliquée à un étudiant pour un retard de soumission. Sa gestion par le Responsable Scolarité est un prérequis au déblocage du compte de l'étudiant.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Etudiant; 

use App\\Backend\\Model\\AnneeAcademique; 

use App\\Backend\\Model\\StatutPenaliteRef; 

use App\\Backend\\Model\\PersonnelAdministratif; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Penalite extends BaseModel 



● **Propriétés **

○ private string $id\_penalite; 

○ private string $numero\_carte\_etudiant; 

○ private string $id\_annee\_academique; 

○ private string $type\_penalite; // enum\('Financière','Administrative'\) 

○ private?float $montant\_du; 

○ private?string $motif; 

○ private string $id\_statut\_penalite; 

○ private DateTime $date\_creation; 

○ private?DateTime $date\_regularisation; 

○ private?string $numero\_personnel\_traitant; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getEtudiant\(\):?Etudiant 

■ public function getAnneeAcademique\(\):?AnneeAcademique 

■ public function getStatutPenalite\(\):?StatutPenaliteRef 

■ public function getPersonnelTraitant\(\):?PersonnelAdministratif 

○ **Logique Métier** : 

■ public function isDue\(\): bool 

■ public function regulariser\(string $numero\_personnel\): void **PersonnelAdministratif.php **

****

Modèle contenant les informations de profil d'un membre du personnel administratif, découplé de son compte Utilisateur. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Utilisateur; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class PersonnelAdministratif extends BaseModel 



● **Propriétés **

○ private string $numero\_personnel\_administratif; 

○ private string $nom; 

○ private string $prenom; 

○ private?string $telephone\_professionnel; 

○ private?string $email\_professionnel; 

○ private?DateTime $date\_affectation\_service; 

○ private?string $responsabilites\_cles; 

○ private string $numero\_utilisateur; 

○ //... autres propriétés personnel es \(naissance, adresse, etc.\) 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getUtilisateur\(\):?Utilisateur 

○ **Logique Métier** : 

■ public function getNomComplet\(\): string 



**Pister.php **

****

Table d'audit spécifique qui trace l'accès \(ou la tentative d'accès\) d'un utilisateur à une permission \(traitement\) donnée. C'est un outil de surveil ance de la sécurité. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Utilisateur; 

use App\\Backend\\Model\\Traitement; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Pister extends BaseModel 



● **Propriétés **

○ private string $id\_piste; 

○ private string $numero\_utilisateur; 

○ private string $id\_traitement; 

○ private DateTime $date\_pister; 

○ private bool $acceder; // true si l'accès a été autorisé, false sinon 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getUtilisateur\(\):?Utilisateur 

■ public function getTraitement\(\):?Traitement 



**PvSessionRapport.php **

****

Modèle de liaison \(M:N\) qui associe un PV de type "Session" à tous les rapports qui ont été évalués durant cette session. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\CompteRendu; 

use App\\Backend\\Model\\RapportEtudiant; 



● **Définition de la Classe** 

PHP 

class PvSessionRapport extends BaseModel 



● **Propriétés **

○ private string $id\_compte\_rendu; 

○ private string $id\_rapport\_etudiant; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdCompteRendu\(\), setIdCompteRendu\(string $id\), getIdRapportEtudiant\(\), setIdRapportEtudiant\(string $id\) 

○ **Méthodes de Relation** : 

■ public function getCompteRendu\(\):?CompteRendu 

■ public function getRapportEtudiant\(\):?RapportEtudiant 



**RapportEtudiant.php **

****

Ce modèle est une entité centrale de l'application. Il représente le travail de l'étudiant et agit comme une machine à états, son cycle de vie étant gouverné par son statut. 

Les méthodes de ce modèle doivent encapsuler toute la logique de transition d'état décrite dans les spécifications fonctionnel es.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Etudiant; 

use App\\Backend\\Model\\StatutRapportRef; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class RapportEtudiant extends BaseModel 



● **Propriétés **

○ private string $id\_rapport\_etudiant; 

○ private string $libel e\_rapport\_etudiant; 

○ private?string $theme; 

○ private?string $resume; 

○ private?string $numero\_attestation\_stage; 

○ private string $numero\_carte\_etudiant; 

○ private?int $nombre\_pages; 

○ private string $id\_statut\_rapport; 

○ private?DateTime $date\_soumission; 

○ private?DateTime $date\_derniere\_modif; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getEtudiant\(\):?Etudiant 

■ public function getStatut\(\):?StatutRapportRef 

■ public function getSections\(\): array // Récupère les objets SectionRapport 

■ public function getAffectations\(\): array // Récupère les objets Affecter 

■ public function getDirecteurMemoire\(\):?Enseignant 

■ public function getApprobationConformite\(\):?Approuver 

■ public function getVotes\(\): array // Récupère les objets VoteCommission 

■ public function getCompteRendu\(\):?CompteRendu 

○ **Logique Métier \(Machine à états\)** : 

■ public function isBrouil on\(\): bool 

■ public function isSoumis\(\): bool 

■ public function isEnCorrection\(\): bool 

■ public function isValide\(\): bool 

■ public function soumettre\(\): void 

■ public function retournerPourCorrection\(string $statutCible\): void 

■ public function passerEnCommission\(\): void 

■ public function finaliserDecision\(string $statutFinal\): void 

■ public function estVerrouil ePourEtudiant\(\): bool 



**RapportModele.php **

****

Ce modèle définit un gabarit de rapport, avec un nom, une description et une version. 

Il sert de conteneur pour un ensemble de sections prédéfinies.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class RapportModele extends BaseModel 



● **Propriétés **

○ private string $id\_modele; 

○ private string $nom\_modele; 

○ private?string $description; 

○ private string $version; 

○ private string $statut; // enum\('Brouil on','Publié','Archivé'\) 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getSectionsModele\(\): array // Récupère les objets RapportModeleSection 

■ public function getNiveauxEtudeAssignes\(\): array // Récupère les objets NiveauEtude via RapportModeleAssignation 

○ **Logique Métier** : 

■ public function publier\(\): void 

■ public function archiver\(\): void 



**RapportModeleAssignation.php **

****

Modèle de liaison \(M:N\) qui assigne un modèle de rapport à un ou plusieurs niveaux d'étude, permettant de proposer les bons gabarits aux bons étudiants. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\RapportModele; 

use App\\Backend\\Model\\NiveauEtude; 



● **Définition de la Classe** 

PHP 

class RapportModeleAssignation extends BaseModel 



● **Propriétés **

○ private string $id\_modele; 

○ private string $id\_niveau\_etude; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdModele\(\), setIdModele\(string $id\), getIdNiveauEtude\(\), setIdNiveauEtude\(string $id\) 

○ **Méthodes de Relation** : 

■ public function getRapportModele\(\):?RapportModele 

■ public function getNiveauEtude\(\):?NiveauEtude 



**RapportModeleSection.php **

****

Définit une section spécifique \(titre, contenu par défaut, ordre\) au sein d'un modèle de rapport. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\RapportModele; 



● **Définition de la Classe** 

PHP 

class RapportModeleSection extends BaseModel 



● **Propriétés **

○ private string $id\_section\_modele; 

○ private string $id\_modele; 

○ private string $titre\_section; 

○ private?string $contenu\_par\_defaut; 

○ private int $ordre; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getRapportModele\(\):?RapportModele 



**Rattacher.php **

****

Modèle de liaison \(M:N\) qui constitue la matrice de permissions du système RBAC. 

Chaque entrée signifie qu'un groupe d'utilisateurs \(id\_groupe\_utilisateur\) a le droit d'effectuer une action spécifique \(id\_traitement\).1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\GroupeUtilisateur; 

use App\\Backend\\Model\\Traitement; 



● **Définition de la Classe** 

PHP 

class Rattacher extends BaseModel 



● **Propriétés **

○ private string $id\_groupe\_utilisateur; 

○ private string $id\_traitement; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdGroupeUtilisateur\(\), setIdGroupeUtilisateur\(string $id\), getIdTraitement\(\), setIdTraitement\(string $id\) 

○ **Méthodes de Relation** : 

■ public function getGroupeUtilisateur\(\):?GroupeUtilisateur 

■ public function getTraitement\(\):?Traitement 



**Recevoir.php **

****

Ce modèle lie une notification à son destinataire et suit son état de lecture. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Utilisateur; 

use App\\Backend\\Model\\Notification; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Recevoir extends BaseModel 



● **Propriétés **

○ private string $id\_reception; 

○ private string $numero\_utilisateur; 

○ private string $id\_notification; 

○ private DateTime $date\_reception; 

○ private bool $lue; 

○ private?DateTime $date\_lecture; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getUtilisateur\(\):?Utilisateur 

■ public function getNotification\(\):?Notification 

○ **Logique Métier** : 

■ public function marquerCommeLue\(\): void 



**Reclamation.php **

****

Modèle gérant les réclamations soumises par les étudiants. Il trace le sujet, la description, le statut du traitement, la réponse apportée et le personnel en charge.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Etudiant; 

use App\\Backend\\Model\\StatutReclamationRef; 

use App\\Backend\\Model\\PersonnelAdministratif; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Reclamation extends BaseModel 



● **Propriétés **

○ private string $id\_reclamation; 

○ private string $numero\_carte\_etudiant; 

○ private string $sujet\_reclamation; 

○ private string $description\_reclamation; 

○ private DateTime $date\_soumission; 

○ private string $id\_statut\_reclamation; 

○ private?string $reponse\_reclamation; 

○ private?DateTime $date\_reponse; 

○ private?string $numero\_personnel\_traitant; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getEtudiant\(\):?Etudiant 

■ public function getStatutReclamation\(\):?StatutReclamationRef 

■ public function getPersonnelTraitant\(\):?PersonnelAdministratif 

○ **Logique Métier** : 

■ public function assigner\(string $numero\_personnel\): void 

■ public function repondreEtCloturer\(string $reponse\): void **Rendre.php **

****

Modèle de liaison qui enregistre l'action d'un enseignant \(rédaction, approbation\) sur un Procès-Verbal. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Enseignant; 

use App\\Backend\\Model\\CompteRendu; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Rendre extends BaseModel 



● **Propriétés **

○ private string $numero\_enseignant; 

○ private string $id\_compte\_rendu; 

○ private DateTime $date\_action\_sur\_pv; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getEnseignant\(\):?Enseignant 

■ public function getCompteRendu\(\):?CompteRendu 



**SectionRapport.php **

****

Ce modèle stocke le contenu textuel d'une section spécifique d'un rapport d'étudiant. 

L'approche "tout textuel" est une innovation clé du système, et ce modèle en est la brique de base.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\RapportEtudiant; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class SectionRapport extends BaseModel 



● **Propriétés **

○ private string $id\_section; 

○ private string $id\_rapport\_etudiant; 

○ private string $titre\_section; 

○ private?string $contenu\_section; // longtext 

○ private int $ordre; 

○ private DateTime $date\_creation; 

○ private?DateTime $date\_derniere\_modif; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getRapportEtudiant\(\):?RapportEtudiant 



**Sequences.php **

****

Modèle technique au cœur du service IdentifiantGenerator. Chaque instance représente un compteur annuel pour un type d'entité, assurant la génération d'identifiants uniques, lisibles et robustes face à la concurrence.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class Sequences extends BaseModel 



● **Propriétés **

○ private string $nom\_sequence; 

○ private int $annee; 

○ private int $valeur\_actuel e; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Logique Métier** : 

■ public function incrementer\(\): void 



**SessionRapport.php **

****

Modèle de liaison \(M:N\) qui rattache les rapports à évaluer à une session de validation 

spécifique. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\SessionValidation; 

use App\\Backend\\Model\\RapportEtudiant; 



● **Définition de la Classe** 

PHP 

class SessionRapport extends BaseModel 



● **Propriétés **

○ private string $id\_session; 

○ private string $id\_rapport\_etudiant; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdSession\(\), setIdSession\(string $id\), getIdRapportEtudiant\(\), setIdRapportEtudiant\(string $id\) 

○ **Méthodes de Relation** : 

■ public function getSessionValidation\(\):?SessionValidation 

■ public function getRapportEtudiant\(\):?RapportEtudiant 



**Sessions.php **

****

Modèle technique pour la gestion des sessions PHP en base de données. Il est crucial pour la mise à jour en temps réel des permissions des utilisateurs connectés, une exigence de sécurité avancée du système.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Utilisateur; 



● **Définition de la Classe** 

PHP 

class Sessions extends BaseModel 



● **Propriétés **

○ private string $session\_id; 

○ private?string $user\_id; 

○ private?string $session\_data; // blob 

○ private mixed $session\_last\_access; // timestamp 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getUtilisateur\(\):?Utilisateur 



**SessionValidation.php **

****

Ce modèle représente une session de travail de la commission. C'est un conteneur qui regroupe des rapports à évaluer, gère son propre cycle de vie \(planifiée, en cours, clôturée\) et est piloté par un président.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Enseignant; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class SessionValidation extends BaseModel 



● **Propriétés **

○ private string $id\_session; 

○ private string $nom\_session; 

○ private?DateTime $date\_debut\_session; 

○ private?DateTime $date\_fin\_prevue; 

○ private DateTime $date\_creation; 

○ private string $id\_president\_session; 

○ private string $mode\_session; // enum\('presentiel','en\_ligne'\) 

○ private string $statut\_session; // enum\('planifiee','en\_cours','cloturee'\) 

○ private?int $nombre\_votants\_requis; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getPresident\(\):?Enseignant 

■ public function getRapports\(\): array // Récupère les objets RapportEtudiant via SessionRapport 

■ public function getMembres\(\): array // La logique pour déterminer les membres est implicite \(tous les votants\) 

○ **Logique Métier** : 

■ public function demarrerSession\(\): void 

■ public function cloturerSession\(\): bool // Retourne false si tous les rapports ne sont pas statués 

■ public function ajouterRapport\(string $id\_rapport\_etudiant\): void 

■ public function retirerRapport\(string $id\_rapport\_etudiant\): void 

■ public function tousRapportsEvalues\(\): bool 



**Specialite.php **

****

Référentiel des spécialités de formation \(ex: MIAGE\), potentiel ement rattaché à un enseignant responsable. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\Enseignant; 



● **Définition de la Classe** 

PHP 

class Specialite extends BaseModel 



● **Propriétés **

○ private string $id\_specialite; 

○ private string $libel e\_specialite; 

○ private?string $numero\_enseignant\_specialite; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getResponsableSpecialite\(\):?Enseignant 



**StatutConformiteRef.php **

****

Référentiel des statuts de la vérification de conformité \(Conforme, Non Conforme\). 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class StatutConformiteRef extends BaseModel 



● **Propriétés **

○ private string $id\_statut\_conformite; 

○ private string $libel e\_statut\_conformite; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdStatutConformite\(\), setIdStatutConformite\(string $id\), getLibel eStatutConformite\(\), setLibel eStatutConformite\(string $libel e\) **StatutJury.php **

****

Référentiel du statut d'un enseignant au sein d'une commission \(Président, Membre, Rapporteur\). 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class StatutJury extends BaseModel 



● **Propriétés **

○ private string $id\_statut\_jury; 

○ private string $libel e\_statut\_jury; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdStatutJury\(\), setIdStatutJury\(string $id\), getLibel eStatutJury\(\), setLibel eStatutJury\(string $libel e\) **StatutPaiementRef.php **

****

Référentiel des statuts de paiement des frais d'inscription \(Payé, En attente, Exonéré\). 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class StatutPaiementRef extends BaseModel 



● **Propriétés **

○ private string $id\_statut\_paiement; 

○ private string $libel e\_statut\_paiement; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdStatutPaiement\(\), setIdStatutPaiement\(string $id\), getLibel eStatutPaiement\(\), setLibel eStatutPaiement\(string $libel e\) **StatutPenaliteRef.php **

****

Référentiel des statuts d'une pénalité \(Due, Réglée, Annulée\). 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class StatutPenaliteRef extends BaseModel 



● **Propriétés **

○ private string $id\_statut\_penalite; 

○ private string $libel e\_statut\_penalite; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdStatutPenalite\(\), setIdStatutPenalite\(string $id\), getLibel eStatutPenalite\(\), setLibel eStatutPenalite\(string $libel e\) **StatutPvRef.php **

****

Référentiel des statuts d'un Procès-Verbal \(En rédaction, En validation, Validé, Rejeté\). 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class StatutPvRef extends BaseModel 



● **Propriétés **

○ private string $id\_statut\_pv; 

○ private string $libel e\_statut\_pv; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdStatutPv\(\), setIdStatutPv\(string $id\), getLibel eStatutPv\(\), setLibel eStatutPv\(string $libel e\) 



**StatutRapportRef.php **

****

Référentiel des statuts d'un rapport, qui définit les étapes du workflow de validation. 

Le champ etape\_workflow est crucial pour l'affichage du suivi visuel côté étudiant.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class StatutRapportRef extends BaseModel 



● **Propriétés **

○ private string $id\_statut\_rapport; 

○ private string $libel e\_statut\_rapport; 

○ private?int $etape\_workflow; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 



**StatutReclamationRef.php **

****

Référentiel des statuts d'une réclamation \(Reçue, En cours, Clôturée, Rejetée\). 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class StatutReclamationRef extends BaseModel 



● **Propriétés **

○ private string $id\_statut\_reclamation; 

○ private string $libel e\_statut\_reclamation; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdStatutReclamation\(\), setIdStatutReclamation\(string $id\), getLibel eStatutReclamation\(\), setLibel eStatutReclamation\(string $libel e\) **Traitement.php **

****

Référentiel de toutes les permissions granulaires possibles dans l'application \(ex: TRAIT\_RAPPORT\_SOUMETTRE\). C'est le catalogue des actions protégées par le système RBAC.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class Traitement extends BaseModel 



● **Propriétés **

○ private string $id\_traitement; 

○ private string $libel e\_traitement; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdTraitement\(\), setIdTraitement\(string $id\), getLibel eTraitement\(\), setLibel eTraitement\(string $libel e\) **TypeDocumentRef.php **

****

Référentiel des types de documents que le système peut générer \(PV, Attestation de scolarité, etc.\). 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class TypeDocumentRef extends BaseModel 



● **Propriétés **

○ private string $id\_type\_document; 

○ private string $libel e\_type\_document; 

○ private?bool $requis\_ou\_non; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 



**TypeUtilisateur.php **

****

Référentiel définissant la catégorie générale d'un utilisateur \(Étudiant, Enseignant, Personnel Administratif, Administrateur\). Ce type est utilisé pour lier un compte Utilisateur à son profil métier spécifique. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class TypeUtilisateur extends BaseModel 



● **Propriétés **

○ private string $id\_type\_utilisateur; 

○ private string $libel e\_type\_utilisateur; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : getIdTypeUtilisateur\(\), setIdTypeUtilisateur\(string $id\), getLibel eTypeUtilisateur\(\), setLibel eTypeUtilisateur\(string $libel e\) **Ue.php **

****

Référentiel des Unités d'Enseignement, qui regroupent des matières \(ECUE\). 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 



● **Définition de la Classe** 

PHP 

class Ue extends BaseModel 



● **Propriétés **

○ private string $id\_ue; 

○ private string $libel e\_ue; 

○ private?int $credits\_ue; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getEcues\(\): array 



**Utilisateur.php **

****

Modèle d'ancrage pour la sécurité et l'identité. Il gère l'authentification \(login, mot de passe\), la sécurité \(2FA, blocage de compte, validation email\) et les droits d'accès via ses liaisons avec les tables du RBAC. Le découplage entre cette entité et les profils métier \(Etudiant, Enseignant\) est une décision architecturale fondamentale pour la flexibilité et la maintenabilité du système.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\GroupeUtilisateur; 

use App\\Backend\\Model\\TypeUtilisateur; 

use App\\Backend\\Model\\NiveauAccesDonne; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class Utilisateur extends BaseModel 



● **Propriétés **

○ private string $numero\_utilisateur; 

○ private string $login\_utilisateur; 

○ private?string $email\_principal; 

○ private string $mot\_de\_passe; 

○ private DateTime $date\_creation; 

○ private?DateTime $derniere\_connexion; 

○ private?string $token\_reset\_mdp; 

○ private?DateTime $date\_expiration\_token\_reset; 

○ private?string $token\_validation\_email; 

○ private bool $email\_valide; 

○ private int $tentatives\_connexion\_echouees; 

○ private?DateTime $compte\_bloque\_jusqua; 

○ private bool $preferences\_2fa\_active; 

○ private?string $secret\_2fa; 

○ private?string $photo\_profil; 

○ private string $statut\_compte; 

○ private string $id\_niveau\_acces\_donne; 

○ private string $id\_groupe\_utilisateur; 

○ private string $id\_type\_utilisateur; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getGroupe\(\):?GroupeUtilisateur 

■ public function getType\(\):?TypeUtilisateur 

■ public function getNiveauAcces\(\):?NiveauAccesDonne 

■ public function getProfil\(\): Etudiant|Enseignant|PersonnelAdministratif|nul 

// Méthode polymorphique 

■ public function getHistoriqueMotsDePasse\(\): array 

○ **Logique Métier et Sécurité** : 

■ public function verifierMotDePasse\(string $password\): bool 

■ public function changerMotDePasse\(string $new\_password\): void 

■ public function isActif\(\): bool 

■ public function isBloque\(\): bool 

■ public function incrementerTentativeEchouee\(\): void 

■ public function reinitialiserTentativesEchouees\(\): void 

■ public function bloquerCompte\(int $minutes\): void 

■ public function genererTokenResetMdp\(\): string 

■ public function genererTokenValidationEmail\(\): string 

■ public function validerEmail\(\): void 

■ public function activer2FA\(\): string // Retourne le secret 

■ public function desactiver2FA\(\): void 

■ public function aPermission\(string $id\_traitement\): bool // Déléguera au service d'habilitation 

■ public function getPermissions\(\): array **ValidationPv.php **

****

Ce modèle enregistre l'acte d'approbation \(ou de demande de modification\) d'un projet de PV par un membre de la commission. Il est la brique élémentaire du circuit de validation col égiale des PV.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\CompteRendu; 

use App\\Backend\\Model\\Enseignant; 

use App\\Backend\\Model\\DecisionValidationPvRef; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class ValidationPv extends BaseModel 



● **Propriétés **

○ private string $id\_compte\_rendu; 

○ private string $numero\_enseignant; 

○ private string $id\_decision\_validation\_pv; 

○ private DateTime $date\_validation; 

○ private?string $commentaire\_validation\_pv; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getCompteRendu\(\):?CompteRendu 

■ public function getEnseignant\(\):?Enseignant 

■ public function getDecision\(\):?DecisionValidationPvRef 



**VoteCommission.php **

****

Ce modèle représente un vote atomique et non répudiable. Chaque instance est une preuve de la décision d'un membre pour un rapport donné, à un tour de scrutin spécifique. La présence du tour\_vote est fondamentale pour gérer les délibérations en plusieurs tours sans perdre l'historique.1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Model; 



use App\\Backend\\Model\\BaseModel; 

use App\\Backend\\Model\\SessionValidation; 

use App\\Backend\\Model\\RapportEtudiant; 

use App\\Backend\\Model\\Enseignant; 

use App\\Backend\\Model\\DecisionVoteRef; 

use DateTime; 



● **Définition de la Classe** 

PHP 

class VoteCommission extends BaseModel 



● **Propriétés **

○ private string $id\_vote; 

○ private string $id\_session; 

○ private string $id\_rapport\_etudiant; 

○ private string $numero\_enseignant; 

○ private string $id\_decision\_vote; 

○ private?string $commentaire\_vote; 

○ private DateTime $date\_vote; 

○ private int $tour\_vote; 

● **Fonctionnalités \(Méthodes\) **

○ \_\_construct\(\) 

○ **Accesseurs** : Tous les getters/setters correspondants. 

○ **Méthodes de Relation** : 

■ public function getSession\(\):?SessionValidation 

■ public function getRapport\(\):?RapportEtudiant 

■ public function getVotant\(\):?Enseignant 

■ public function getDecision\(\):?DecisionVoteRef **Sources des citations **

1. MySoutenance.txt 



**Rapport de Spécification Technique Finale et Conception** **d'Outils de Développement **

****

****

**Partie I : Finalisation du Blueprint d'Infrastructure Applicative **

****

Cette partie établit les fondations techniques sur lesquel es reposera l'ensemble de l'application "GestionMySoutenance". El e définit comment l'application est configurée, comment el e démarre, et comment el e oriente les requêtes entrantes vers la logique métier appropriée, assurant ainsi une base robuste, sécurisée et maintenable pour le développement futur. 



**Section 1 : Configuration de l'Environnement et Cycle de Vie de la Requête **

****

Cette section détail e les prérequis de configuration et le processus d'amorçage de l'application, depuis la lecture des paramètres d'environnement jusqu'à l'exécution du contrôleur final, en passant par la gestion de la requête HTTP par le serveur web. 



**1.1. Spécification du Fichier d'Environnement .env **

****

Le fichier .env constitue la pierre angulaire de la configuration de l'application. Géré par la bibliothèque vlucas/phpdotenv, identifiée comme une dépendance du projet 1, il permet une dissociation complète entre le code source et les paramètres de configuration, en particulier les informations sensibles. Cette pratique est non seulement une norme de sécurité fondamentale, mais el e offre également une flexibilité considérable pour le déploiement de l'application dans différents environnements \(développement, test, production\) sans aucune modification du code. 

Le plan d'implémentation requiert la définition exhaustive des variables d'environnement suivantes, regroupées par fonctionnalité pour une clarté maximale. 

Un fichier .env.example sera maintenu dans le dépôt de code pour servir de modèle aux développeurs et aux administrateurs système. 

Configuration de la Base de Données 

Ces variables sont indispensables pour permettre à l'application d'établir une connexion avec la base de données MySQL, dont le schéma est défini en détail.1 

● DB\_CONNECTION: Le pilote de base de données à utiliser. Défini à mysql. 

● DB\_HOST: L'adresse du serveur de base de données. Typiquement 127.0.0.1 ou localhost en développement, ou l'adresse d'un service de base de données dédié en production. 

● DB\_PORT: Le port d'écoute du serveur de base de données. La valeur par défaut pour MySQL est 3306. 

● DB\_DATABASE: Le nom de la base de données spécifique au projet, soit mysoutenance.1 

● DB\_USERNAME: Le nom d'utilisateur pour l'authentification auprès de la base de données. 

● DB\_PASSWORD: Le mot de passe associé à l'utilisateur de la base de données. 

Cette valeur est hautement sensible et ne doit jamais être versionnée. 

Configuration de l'Application 

Ces variables définissent le comportement global et l'identité de l'application. 

● APP\_NAME: Le nom de l'application, utilisé dans les titres de page et les notifications. Ex: "GestionMySoutenance". 

● APP\_ENV: L'environnement d'exécution actuel. Ses valeurs peuvent être development, testing, ou production. Cette variable conditionne des comportements clés comme le niveau de détail des messages d'erreur. 

● APP\_KEY: Une clé de chiffrement secrète, qui doit être une chaîne de 32 

caractères aléatoires. El e est utilisée pour sécuriser les sessions et d'autres données chiffrées. El e doit être unique pour chaque instal ation. 

● APP\_DEBUG: Un booléen \(true ou false\) qui active ou désactive le mode de débogage. En mode true, des informations de débogage détail ées sont affichées en cas d'erreur. Ce paramètre doit impérativement être à false en production. 

● APP\_URL: L'URL de base de l'application. Ex: http://localhost:8080. 

Configuration du Service d'Email \(Mailer\) 

Ces paramètres sont critiques pour l'ensemble des fonctionnalités de communication de l'application, tel es que la validation des comptes email, la réinitialisation des mots de passe, et l'envoi de toutes les notifications métier décrites dans les spécifications fonctionnel es.1 

● MAIL\_MAILER: Le protocole à utiliser pour l'envoi d'emails. La valeur recommandée est smtp. 

● MAIL\_HOST: L'adresse du serveur SMTP. 

● MAIL\_PORT: Le port du serveur SMTP \(ex: 587 pour TLS, 465 pour SSL\). 

● MAIL\_USERNAME: Le nom d'utilisateur pour s'authentifier auprès du serveur SMTP. 

● MAIL\_PASSWORD: Le mot de passe pour l'authentification SMTP. 

● MAIL\_ENCRYPTION: Le protocole de chiffrement à utiliser. Typiquement tls ou ssl. 

● MAIL\_FROM\_ADDRESS: L'adresse email qui apparaîtra comme expéditeur des emails système. 

● MAIL\_FROM\_NAME: Le nom qui apparaîtra comme expéditeur, typiquement la valeur de APP\_NAME. 

Paramètres Métier Configurables 

Ces variables permettent de modifier des règles de gestion critiques sans intervention dans le code, offrant une grande souplesse à l'administrateur. 

● SESSION\_LIFETIME: La durée de vie d'une session utilisateur en minutes. 

● PASSWORD\_RESET\_TOKEN\_LIFETIME: La durée de validité en minutes d'un jeton de réinitialisation de mot de passe. 

● FAILED\_LOGIN\_ATTEMPTS\_LOCKOUT\_THRESHOLD: Le nombre de tentatives de connexion échouées avant le blocage d'un compte. Par exemple, 5. 

● FAILED\_LOGIN\_ATTEMPTS\_LOCKOUT\_DURATION: La durée en minutes pendant laquel e un compte est bloqué après avoir atteint le seuil de tentatives échouées. 

Par exemple, 15. Ces deux dernières variables sont directement liées à la fonctionnalité de protection contre les attaques par force brute.1 



**1.2. Point d'Entrée Public et Séquence d'Amorçage \(Public/index.php\) **

****

Le répertoire Public est le seul point d'accès web de l'application, une pratique de sécurité standard connue sous le nom de "Document Root" qui empêche l'accès direct aux fichiers de logique métier, aux dépendances ou aux fichiers de configuration.1 Le fichier 

Public/index.php agit comme un "Contrôleur Frontal" \(Front Control er\), un point d'entrée unique qui intercepte et traite toutes les requêtes HTTP destinées à l'application. 

La séquence d'amorçage \(bootstrap\) de l'application, exécutée dans ce fichier, est un processus ordonné et critique qui prépare l'environnement avant de pouvoir traiter la requête de l'utilisateur. 

1. **Chargement de l'Autoloader Composer :** L'instruction require \_\_DIR\_\_.'/../vendor/autoload.php'; est la toute première étape. El e charge le chargeur de classes automatique généré par Composer, qui permet à l'application de trouver et d'utiliser toutes les classes des dépendances du projet \(comme FastRoute et PHPMailer\) ainsi que les propres classes de l'application définies dans le composer.json \(App\\\\ pointant vers src/\).1 

2. **Chargement des Variables d'Environnement :** Le code initialise la bibliothèque Dotenv pour lire le fichier .env situé à la racine du projet et charger ses variables dans l'environnement d'exécution de PHP \(via $\_ENV et getenv\(\)\). 

3. **Initialisation du Conteneur d'Injection de Dépendances \(DIC\) :** L'architecture modulaire et orientée services de l'application 1 implique l'utilisation d'un conteneur d'injection de dépendances \(par exemple, PHP-DI\). Ce conteneur est configuré ici. Il est responsable de l'instanciation des objets \(services, contrôleurs, modèles\) et de la résolution automatique de leurs dépendances. Par exemple, lorsqu'un contrôleur a besoin du 

UtilisateurService, le conteneur l'injecte automatiquement dans son constructeur. 

4. **Configuration de la Gestion des Erreurs :** En fonction de la valeur de la variable d'environnement APP\_DEBUG, un gestionnaire d'erreurs approprié est enregistré. 

En mode développement \(APP\_DEBUG=true\), un outil comme Whoops peut être utilisé pour afficher des pages d'erreur détail ées. En production \(APP\_DEBUG=false\), toutes les erreurs sont capturées et consignées dans un fichier de log \(par exemple, via Monolog\) et une page d'erreur générique est présentée à l'utilisateur.1 

5. **Initialisation de la Session :** La gestion des sessions est initiée. Conformément aux spécifications pour la mise à jour des droits en temps réel 1, le gestionnaire de session par défaut de PHP est remplacé par le gestionnaire personnalisé DatabaseSessionHandler.1 L'instruction 

session\_set\_save\_handler\(new App\\Backend\\Util\\DatabaseSessionHandler\(...\)\); est appelée avant session\_start\(\);. Cela force PHP à stocker les données de session dans la table sessions de la base de données 1, rendant les sessions modifiables par le système lui-même. 

6. **Instanciation et Configuration du Routeur :** Une instance du routeur nikic/fast-route est créée.1 Les définitions de routes, contenues dans routes/web.php, sont chargées et enregistrées auprès du routeur. 

7. **Dispatch de la Requête :** Enfin, le routeur analyse l'URI et la méthode HTTP de la 

requête entrante. Il la compare aux routes enregistrées et, s'il trouve une correspondance, il exécute le gestionnaire associé \(typiquement une méthode d'un contrôleur\). Les données de la requête \(comme les paramètres d'URL ou les données de formulaire\) sont transmises au contrôleur pour traitement. 



**1.3. Configuration du Serveur Web \(.htaccess\) **

****

Pour que le modèle de Contrôleur Frontal fonctionne correctement avec un serveur web comme Apache, il est nécessaire de configurer la réécriture d'URL. Le fichier 

.htaccess placé dans le répertoire Public a pour rôle de rediriger toutes les requêtes qui ne correspondent pas à un fichier physique existant \(comme style.css ou logo.png\) vers le point d'entrée unique index.php. 

Le contenu standard et commenté de ce fichier sera le suivant : Apache 





<IfModule mod\_rewrite.c> 

\# Activer le moteur de réécriture d'URL 

RewriteEngine On 



\# Rediriger toutes les requêtes qui ne sont PAS des fichiers existants... 

RewriteCond %\{REQUEST\_FILENAME\}\!-f 

\#...ni des répertoires existants... 

RewriteCond %\{REQUEST\_FILENAME\}\!-d 

\#...vers le contrôleur frontal index.php. 

\# ajoute les paramètres de la requête originale. 

\# \[L\] indique que c'est la dernière règle à appliquer. 

RewriteRule ^ index.php 

</IfModule> 



Au-delà de cette fonction de base, une approche de sécurité en profondeur doit être mise en œuvre. Le répertoire Public est la seule porte d'entrée légitime vers l'application. Les autres répertoires \(src, routes, vendor\) contiennent du code source sensible qui ne doit en aucun cas être accessible directement via un navigateur. Bien 

que la configuration du serveur web \(Virtual Host\) doive déjà l'interdire en définissant le DocumentRoot sur le dossier Public, une couche de protection supplémentaire est une bonne pratique. Pour ce faire, des fichiers .htaccess contenant la directive unique Deny from al seront placés à la racine des répertoires sensibles \(src/, routes/, etc.\). 

Cette mesure simple mais efficace garantit que même en cas de mauvaise configuration du serveur, ces fichiers critiques resteront protégés. 



**Section 2 : Architecture et Implémentation du Routage Stratégique** **\(routes/web.php\) **

****

Le fichier de routage routes/web.php est la carte routière de l'application. Il définit chaque point d'accès \(endpoint\) disponible, la méthode HTTP autorisée pour y accéder, et le contrôleur responsable de traiter la requête. Une conception de routage claire, sécurisée et maintenable est un facteur de succès critique pour un projet de cette envergure. 



**2.1. Principes Directeurs du Routage **

****

Pour garantir la lisibilité et la maintenabilité à long terme, l'organisation du fichier routes/web.php suivra des principes stricts. 

● **Groupement Logique par Module :** Les routes seront organisées en groupes qui reflètent la structure des modules fonctionnels de l'application et l'arborescence des contrôleurs.1 Des préfixes d'URL seront utilisés pour délimiter ces groupes. 

Par exemple, toutes les routes liées à l'administration commenceront par 

/admin, cel es de la commission par /commission, etc. Cette organisation rend le fichier de routes auto-documenté et facilite la recherche de routes spécifiques. 

● **Adoption des Conventions RESTful/CRUD :** Dans la mesure du possible, les routes destinées à la gestion des ressources \(utilisateurs, rapports, sessions\) adhéreront aux conventions de nommage RESTful. Cette approche standardise la manière de nommer les actions de création, lecture, mise à jour et suppression \(CRUD\), ce qui rend l'API interne de l'application prévisible et cohérente. 

○ GET /utilisateurs: Lister tous les utilisateurs \(index action\). 

○ POST /utilisateurs: Créer un nouvel utilisateur \(store action\). 

○ GET /utilisateurs/\{id\}: Afficher un utilisateur spécifique \(show action\). 

○ PUT/PATCH /utilisateurs/\{id\}: Mettre à jour un utilisateur \(update action\). 

○ DELETE /utilisateurs/\{id\}: Supprimer un utilisateur \(destroy action\). 

● **Nommage Explicite des Routes :** Chaque route se verra attribuer un nom unique et descriptif \(par exemple, admin.users.index\). Cette pratique est essentiel e car el e permet de générer des URL de manière programmatique dans les vues et les contrôleurs \(par exemple, <a href="\{\{ route\('admin.users.index'\) \}\}">...</a>\). Cela découple le code de la structure d'URL réel e, permettant de modifier une URI dans le fichier de routes sans avoir à la rechercher et la remplacer dans toute l'application. 



**2.2. Intégration du Contrôle d'Accès au Niveau du Routage **

****

Le système de routage est le point de contrôle idéal pour appliquer la politique de sécurité de l'application de manière centralisée. Plutôt que de disperser les vérifications de permissions dans chaque méthode de contrôleur, ce qui est source d'erreurs et d'oublis, le contrôle d'accès sera intégré directement dans la définition des routes. 

Cette approche s'appuie sur le système de Contrôle d'Accès Basé sur les Rôles \(RBAC\) détail é dans les spécifications, qui repose sur des "traitements" granulaires \(permissions\).1 Le 

HabilitationService 1 est le composant applicatif chargé de vérifier si l'utilisateur courant possède une permission donnée. 

L'implémentation consistera à étendre la fonctionnalité du routeur pour qu'il accepte une permission requise pour chaque route. La définition d'une route ressemblera à ceci : $router->add\('GET', '/admin/utilisateurs', \[Admin\\UtilisateurControl er::class, 

'index'\]\)->permission\('ADMIN\_USER\_LIST\_VIEW'\); 

Le mécanisme de dispatch du routeur sera modifié pour exécuter une fonction 

"middleware" avant d'appeler le contrôleur. Ce middleware effectuera la séquence suivante : 

1. Récupérer l'utilisateur actuel ement authentifié à partir de la session. 

2. Extraire la permission requise associée à la route correspondante \(ici, ADMIN\_USER\_LIST\_VIEW\). 

3. Si aucune permission n'est requise \(route publique\), passer à l'étape suivante. 

4. Invoquer le service d'habilitation : 

$habilitationService->checkPermission\('ADMIN\_USER\_LIST\_VIEW'\). 

5. Si la vérification réussit, l'exécution se poursuit et le contrôleur est appelé. 

6. Si la vérification échoue, le middleware lève une PermissionException.1 Cette exception est capturée par le gestionnaire d'erreurs global, qui interrompt le traitement et renvoie une réponse HTTP 403 \(Forbidden\) à l'utilisateur. 

Cette architecture garantit que chaque point d'accès est sécurisé par défaut. El e simplifie drastiquement le code des contrôleurs, qui peuvent opérer en partant du principe que si leur code est exécuté, c'est que l'utilisateur a déjà été autorisé à effectuer l'action. 



**2.3. Table de Routage Complète **

****

Pour fournir une vision claire et non ambiguë à l'équipe de développement, la table suivante détail e un sous-ensemble représentatif des routes de l'application, en mappant chaque URI à son contrôleur, son action, son nom de route et la permission requise. Cette table servira de référence pour l'implémentation du fichier routes/web.php. 



Méthode 

URI 

Nom de la Route 

Contrôleur::Acti

Permission 

on 

Requise 

\(traitement\) 

**Authentificatio**

****

****

****

****

**n **

GET 

/login 

auth.login.show 

Authentification

PUBLIC 

Control er::show

LoginForm 

POST 

/login 

auth.login.attem

Authentification

PUBLIC 

pt 

Control er::login 

POST 

/logout 

auth.logout 

Authentification

AUTHENTICATE

Control er::logou

D 

t 

GET 

/mot-de-passe-

password.reque

Authentification

PUBLIC 

oublie 

st 

Control er::show

LinkRequestFor

m 

POST 

/mot-de-passe-

password.email 

Authentification

PUBLIC 

oublie 

Control er::send

ResetLinkEmail 

**Tableau de **

****

****

****

****

**Bord Principal **

GET 

/dashboard 

dashboard 

DashboardContr

AUTHENTICATE

ol er::index 

D 

**Module **

****

****

****

****

**Étudiant **

GET 

/etudiant/rappor

etudiant.rapport

Etudiant\\Rappor

ETUDIANT\_RAPP

t/creer 

.create 

tControl er::crea

ORT\_SUBMIT 

te 

POST 

/etudiant/rappor

etudiant.rapport

Etudiant\\Rappor

ETUDIANT\_RAPP

t 

.store 

tControl er::stor

ORT\_SUBMIT 

e 

GET 

/etudiant/rappor

etudiant.rapport

Etudiant\\Rappor

ETUDIANT\_RAPP

t/\{id\}/suivi 

.suivi 

tControl er::sho

ORT\_VIEW\_OWN 

wWorkflow 

GET 

/etudiant/rappor

etudiant.rapport

Etudiant\\Rappor

ETUDIANT\_RAPP

t/\{id\}/modifier 

.edit 

tControl er::edit 

ORT\_EDIT\_OWN 

PUT 

/etudiant/rappor

etudiant.rapport

Etudiant\\Rappor

ETUDIANT\_RAPP

t/\{id\} 

.update 

tControl er::upd

ORT\_EDIT\_OWN 

ate 

GET 

/etudiant/reclam

etudiant.reclam

Etudiant\\Reclam

ETUDIANT\_RECL

ations 

ations.index 

ationControl er::i

AMATION\_VIEW 

ndex 

POST 

/etudiant/reclam

etudiant.reclam

Etudiant\\Reclam

ETUDIANT\_RECL

ations 

ations.store 

ationControl er::

AMATION\_CREA

store 

TE 

**Module **

****

****

****

****

**Personnel **

**Administratif **

GET 

/personnel/conf

conformite.rapp

PersonnelAdmini

CONFORMITE\_R

ormite/rapports 

orts.index 

stratif\\Conformit

APPORT\_LIST 

eControl er::inde

x 

GET 

/personnel/conf

conformite.rapp

PersonnelAdmini

CONFORMITE\_R

ormite/rapports/

orts.show 

stratif\\Conformit

APPORT\_VERIFY 

\{id\} 

eControl er::sho

w 

POST 

/personnel/conf

conformite.rapp

PersonnelAdmini

CONFORMITE\_R

ormite/rapports/

orts.process 

stratif\\Conformit

APPORT\_VERIFY 

\{id\} 

eControl er::pro

cess 

GET 

/personnel/scola

scolarite.activati

PersonnelAdmini

SCOLARITE\_AC

rite/activation 

on.index 

stratif\\Scolarite

COUNT\_ACTIVAT

Control er::show

E 

Activation 

POST 

/personnel/scola

scolarite.activati

PersonnelAdmini

SCOLARITE\_AC

rite/activation 

on.process 

stratif\\Scolarite

COUNT\_ACTIVAT

Control er::proc

E 

essActivation 

**Module **

****

****

****

****

**Commission **

GET 

/commission/ses

commission.ses

Commission\\Ses

COMMISSION\_S

sions 

sions.index 

sionValidationCo

ESSION\_LIST 

ntrol er::index 

POST 

/commission/ses

commission.ses

Commission\\Ses

COMMISSION\_S

sions 

sions.store 

sionValidationCo

ESSION\_CREATE 

ntrol er::store 

GET 

/commission/ses

commission.ses

Commission\\Ses

COMMISSION\_S

sion/\{id\} 

sion.show 

sionValidationCo

ESSION\_VIEW 

ntrol er::show 

POST 

/commission/ses

commission.vote

Commission\\Ses

COMMISSION\_V

sion/\{id\}/vote/\{ra

.store 

sionValidationCo

OTE\_SUBMIT 

pportId\} 

ntrol er::submitV

ote 

GET 

/commission/pv/

commission.pv.e

Commission\\Pv

COMMISSION\_P

\{id\}/rediger 

dit 

Control er::edit 

V\_EDIT 

POST 

/commission/pv/

commission.pv.a

Commission\\Pv

COMMISSION\_P

\{id\}/approuver 

pprove 

Control er::appr

V\_APPROVE 

ove 

**Module **

****

****

****

****

**Administration **

GET 

/admin/utilisateu

admin.users.ind

Administration\\U

ADMIN\_USER\_M

rs 

ex 

tilisateurControl

ANAGE 

er::index 

POST 

/admin/utilisateu

admin.users.stor

Administration\\U

ADMIN\_USER\_M

rs 

e 

tilisateurControl

ANAGE 

er::store 

PUT 

/admin/utilisateu

admin.users.upd

Administration\\U

ADMIN\_USER\_M

rs/\{id\} 

ate 

tilisateurControl

ANAGE 

er::update 

GET 

/admin/habilitati

admin.habilitatio

Administration\\H

ADMIN\_RBAC\_M

ons 

ns.index 

abilitationContro

ANAGE 

l er::index 

POST 

/admin/habilitati

admin.habilitatio

Administration\\H

ADMIN\_RBAC\_M

ons/rattacher 

ns.attach 

abilitationContro

ANAGE 

l er::attach 

GET 

/admin/import 

admin.import.sh

Administration\\I

ADMIN\_DATA\_IM

ow 

mportationContr

PORT 

ol er::show 

POST 

/admin/import/p

admin.import.pr

Administration\\I

ADMIN\_DATA\_IM

rocess 

ocess 

mportationContr

PORT 

ol er::process 



**Partie II : Conception d'un Algorithme de Génération de Code** **Assistée par IA **

****

Cette partie se projette au-delà de l'implémentation actuel e pour concevoir un outil de développement avancé. L'objectif est de créer un algorithme capable de piloter un Grand Modèle de Langage \(LLM\) pour générer automatiquement des modules fonctionnels complets, accélérant ainsi l'évolution future de l'application tout en 

garantissant une adhésion stricte à son architecture. 



**Section 3 : Analyse Stratégique et Identification des Cibles de Génération **

****

Avant de concevoir l'algorithme, il est impératif de définir sa raison d'être stratégique et le périmètre exact de ce qu'il doit produire. 



**3.1. Justification Stratégique **

****

L'application "GestionMySoutenance" est, de par sa nature, un système d'information complexe et de grande envergure, comme en témoignent la richesse des spécifications fonctionnel es 1 et la tail e du schéma de base de données \(60 tables\).1 

L'ajout d'une nouvel e entité métier, même simple \(par exemple, la gestion des 

"Conventions de Stage" ou des "Factures de pénalité"\), est un processus laborieux qui requiert la création et la modification de nombreux fichiers de manière répétitive. 

L'objectif de l'outil de génération de code est triple : 

1. **Réduire le Temps de Développement :** Automatiser la création du code 

"boilerplate" \(code de base répétitif\) pour permettre aux développeurs de se concentrer sur la logique métier à plus forte valeur ajoutée. 

2. **Minimiser les Erreurs Humaines :** Éliminer les erreurs de type "copier-col er", les oublis et les incohérences qui surviennent inévitablement lors de la création manuel e de fichiers similaires. 

3. **Garantir la Cohérence Architecturale :** Forcer le code généré à respecter scrupuleusement les patrons de conception \(design patterns\) et l'architecture établie \(Modèle-Service-Contrôleur, injection de dépendances, nommage des fichiers\), tel e que définie par l'arborescence du projet.1 



**3.2. Cible de Génération : Le "Stack" CRUD Complet **

****

L'efficacité de la génération de code repose sur la régularité et la cohérence de 

l'architecture de l'application cible. L'analyse de l'arborescence du projet 1 et des logiques métier 1 révèle une structure extrêmement standardisée. Pour toute entité métier 

X définie dans la base de données, on retrouve systématiquement : 

● Un fichier de modèle de données X.php dans src/Backend/Model/. 

● Un fichier de service XService.php dans src/Backend/Service/X/ qui encapsule toute la logique métier liée à X. 

● Un fichier de contrôleur XControl er.php dans src/Backend/Control er/ qui gère les requêtes HTTP et utilise le XService. 

● Une série de vues dans src/Frontend/views/ pour les opérations CRUD \(lister, créer/modifier\). 

Par conséquent, l'algorithme ne doit pas se contenter de générer des fichiers isolés. 

Sa véritable puissance résidera dans sa capacité à générer un "stack" vertical complet et interconnecté pour une nouvel e entité. Pour une nouvel e entité Facture, l'outil doit produire l'ensemble des artefacts suivants : 

● **Couche Modèle :** src/Backend/Model/Facture.php 

● **Couche Service :** src/Backend/Service/Facture/FactureService.php et son interface FactureServiceInterface.php. 

● **Couche Contrôleur :** 

src/Backend/Control er/Administration/FactureControl er.php \(en supposant qu'il s'agit d'une ressource gérée par l'administration\). 

● **Couche Vue : **

○ src/Frontend/views/Administration/factures/index.php \(liste des factures\). 

○ src/Frontend/views/Administration/factures/form.php \(formulaire de création/édition\). 

● **Intégration et Configuration : **

○ Ajout automatique des nouvel es routes CRUD dans le fichier routes/web.php. 

○ Création des permissions correspondantes \(ex: ADMIN\_FACTURE\_MANAGE\) dans la table traitement de la base de données.1 



**Section 4 : Conception de l'Algorithme de Prompt et du Workflow de Génération **

****

Cette section décrit le processus technique de génération, en proposant un workflow interactif pour le développeur et une série de prompts intel igents en chaîne \("prompt 

chaining"\) pour piloter le LLM. 



**4.1. Workflow de Génération en Plusieurs Étapes **

****

Un prompt unique et monolithique tel que "génère-moi un CRUD pour une facture" 

serait trop vague et produirait un code générique et de faible qualité, mal intégré à l'architecture spécifique du projet. Un processus guidé, décomposé en étapes logiques, est donc nécessaire pour obtenir un résultat précis et pertinent. 

Le workflow se déroulera comme suit : 

1. **Input Développeur :** Le processus est initié par le développeur qui fournit la définition CREATE TABLE SQL de la nouvel e entité. C'est la source de vérité pour la structure des données. 

2. **Étape 1 : Analyse du Schéma et Génération du Modèle :** L'algorithme analyse la structure SQL pour extraire le nom de la table, les noms des colonnes, leurs types de données, leur nul abilité et les clés étrangères. Sur cette base, il génère le fichier Model PHP correspondant, avec ses propriétés, getters et setters. 

3. **Étape 2 : Génération de la Couche Service :** En utilisant le modèle PHP 

fraîchement généré comme contexte, l'algorithme génère la classe Service et son interface, avec les méthodes CRUD de base \(findById, findAl , create, update, delete\). 

4. **Étape 3 : Génération du Contrôleur :** En s'appuyant sur la classe Service générée, il produit le Control er avec les actions correspondantes \(index, show, store, update, destroy\), qui appel ent les méthodes du service. 

5. **Étape 4 : Génération des Vues :** À partir de la structure du modèle, il génère les fichiers de vue de base : une table HTML pour la liste et un formulaire HTML pour la création/édition. 

6. **Étape 5 : Intégration Automatisée :** L'algorithme modifie programmatiquement les fichiers de configuration pour ajouter les nouvel es routes au fichier routes/web.php et insère les nouvel es permissions dans la table traitement via une requête SQL. 

7. **Output :** Le développeur reçoit un ensemble de fichiers de code source cohérents et fonctionnels, prêts à être personnalisés pour y ajouter la logique métier spécifique. 



**4.2. Catalogue de Prompts Intelligents \(Prompt Chaining\) **

****

Le cœur de l'algorithme est une séquence de prompts ciblés, où chaque prompt s'appuie sur le résultat du précédent pour fournir un contexte de plus en plus riche au LLM. 

**Prompt 1 \(Génération du Modèle PHP à partir du SQL\) **

****

****

****

\# CONTEXTE 

Tu es un architecte logiciel expert en PHP, générant du code pour une application MVC existante. 

Le style de code doit être strict, entièrement typé \(PHP 8.2\+\) et suivre les standards de codage PSR-12. 

Tous les modèles de données héritent de la classe de base suivante, qui ne doit pas être modifiée : 

\`\`\`php 

<?php 

namespace App\\Backend\\Model; 



abstract class BaseModel \{ 

// Contenu de src/Backend/Model/BaseModel.php 

//... 

\} 





**TÂCHE **

****

À partir de la définition de table SQL suivante, génère la classe PHP pour le modèle correspondant. 

● Le nom de la classe doit être la version PascalCase du nom de la table. 

● La classe doit se trouver dans le namespace App\\Backend\\Model. 

● El e doit étendre BaseModel. 

● El e doit inclure des propriétés privées typées pour chaque colonne de la table. 

● El e doit inclure des méthodes publiques getter et setter typées pour chaque propriété. 



**SQL **

****

CREATE TABLE facture\_penalite \( 

id\_facture varchar\(50\) NOT NULL, 

numero\_facture varchar\(100\) NOT NULL, 

montant\_ht decimal\(10,2\) NOT NULL, 

taux\_tva decimal\(5,2\) NOT NULL, 

date\_emission date NOT NULL, 

date\_echeance date NOT NULL, 

id\_penalite varchar\(50\) NOT NULL, 

statut enum\('Brouil on','Emise','Payee','Annulee'\) NOT NULL, PRIMARY KEY \(id\_facture\), 

KEY fk\_facture\_penalite \(id\_penalite\) 

\); 





\*\*Prompt 2 \(Génération du Service à partir du Modèle\)\*\* 





**CONTEXTE **

****

Tu continues de générer du code pour la même application. 

Voici la classe Modèle FacturePenalite.php qui vient d'être générée : PHP 





<?php 

// Contenu du fichier FacturePenalite.php généré à l'étape 1 

?> 



Voici un exemple de classe Service existante \(UtilisateurService.php\) pour référence de style et d'architecture. Note l'usage de l'injection de dépendances pour la connexion à la base de données et l'utilisation d'interfaces. 



PHP 





<?php 

// Contenu complet de src/Backend/Service/Utilisateur/UtilisateurService.php 

?> 





**TÂCHE **

****

Génère la classe FacturePenaliteService et son interface 

FacturePenaliteServiceInterface. 

● Le service doit se trouver dans le namespace 

App\\Backend\\Service\\FacturePenalite. 

● L'interface doit définir les méthodes publiques pour les opérations CRUD de base 

: findById\(string $id\):?FacturePenalite, findAl \(\): array, create\(array $data\): FacturePenalite, update\(string $id, array $data\): FacturePenalite, delete\(string $id\): bool. 

● La classe de service doit implémenter cette interface. 

● La classe doit utiliser l'injection de dépendances via son constructeur pour obtenir une connexion PDO à la base de données. 

● Implémente le corps des méthodes avec des requêtes SQL préparées pour interagir avec la table facture\_penalite. 





Les prompts suivants pour le \*\*Contrôleur\*\* et les \*\*Vues\*\* suivront une logique identique : fournir le contexte des fichiers déjà générés \(Modèle, Service\) ainsi qu'un 

exemple de fichier existant du même type \(un autre Contrôleur, une autre vue\) pour guider le LLM sur la structure, le style et les dépendances à utiliser. 



\#\#\#\# 4.3. Post-Traitement et Intégration 



Le code généré par un LLM, bien que souvent fonctionnel, n'est pas garanti d'être parfait ou de s'intégrer sans heurt. Une étape de post-traitement automatisée est donc indispensable pour finaliser le travail. 



1. \*\*Validation Syntaxique :\*\* Chaque fichier PHP généré sera passé à travers le linter PHP \(\`php -l\`\) pour vérifier l'absence d'erreurs de syntaxe manifestes. 

2. \*\*Formatage du Code :\*\* Un formateur de code, tel que PHP-CS-Fixer, sera exécuté sur les fichiers générés pour garantir une conformité absolue avec les standards de codage \(PSR-12\) du reste du projet. 

3. \*\*Placement des Fichiers :\*\* L'algorithme placera automatiquement chaque fichier généré dans le répertoire approprié, en respectant rigoureusement l'arborescence définie.\[1\] 

4. \*\*Modification des Fichiers d'Intégration :\*\* C'est l'étape la plus délicate. 

L'algorithme devra modifier des fichiers existants : 

\* Il ajoutera un nouveau groupe de routes pour la ressourcèFacturePenalitè à la fin du fichier \`routes/web.php\`. 

\* Il exécutera une requête ÌNSERT\` sur la base de données pour ajouter les nouvel es permissions \(ÀDMIN\_FACTURE\_MANAGÈ, etc.\) à la tablètraitement\`. 



Ce processus complet, de l'input SQL à l'intégration finale, constitue un outil de développement puissant, capable d'accélérer significativement la maintenance et l'évolution de la plateforme "GestionMySoutenance". 



**Sources des citations **

1. Arborescence.txt 

**Plan d'Implémentation Exhaustif : Controller, Exception,** **Worker et Config **

**Introduction : Finalisation de l'Architecture Applicative **

****

Ce document complète le blueprint de l'application "GestionMySoutenance" en détail ant les couches restantes : Config pour l'initialisation et l'injection de dépendances, Exception pour une gestion sémantique des erreurs, Worker pour le traitement des tâches lourdes en asynchrone, et Control er qui orchestre les requêtes HTTP, la logique métier et le rendu des vues. 



**Section 1 : Le Cœur de l'Application - src/Config/ **

****

Ce répertoire est fondamental pour l'amorçage \(bootstrap\) de l'application. Il gère la connexion à la base de données et l'assemblage des services via un conteneur d'injection de dépendances \(DI\). 



**Database.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Config; 



use PDO; 

use PDOException; 



● **Fonctionnalités \(Méthodes\) **

○ private static?PDO $instance = nul ; : Propriété statique pour implémenter le patron de conception Singleton. 

○ public static function getInstance\(\): PDO : Méthode statique qui crée et retourne une instance unique de PDO en lisant les variables d'environnement \(DB\_HOST, DB\_NAME, DB\_USER, DB\_PASS\). Assure qu'une seule connexion à 

la base de données est utilisée par requête. 

○ private function \_\_construct\(\) : Constructeur privé pour empêcher l'instanciation directe. 



**Container.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Config; 



use App\\Backend\\Service\\Audit\\AuditService; 

use App\\Backend\\Service\\Authentification\\AuthenticationService; 

//... inclure tous les 'use' pour chaque service à instancier use PDO; 



● **Fonctionnalités \(Méthodes\) **

○ private array $services =; : Tableau pour stocker les instances de services déjà créées. 

○ public function \_\_construct\(\) : Le constructeur peut initialiser les dépendances de base, comme la connexion PDO. 

○ public function get\(string $serviceInterface\): object : Méthode générique pour récupérer une instance de service. 

○ **Accesseurs de Services Spécifiques** : Une méthode get...Service\(\) pour chaque service de l'application. Ces méthodes sont responsables de l'instanciation des services et de l'injection de leurs dépendances. 

■ public function getAuthenticationService\(\): AuthenticationService : Instancie AuthenticationService en lui injectant le EmailService et potentiel ement d'autres dépendances. 

■ public function getRapportService\(\): RapportService : Instancie RapportService en lui injectant AuditService. 

■ ... et ainsi de suite pour tous les services, garantissant que les dépendances entre services sont correctement résolues. 



**Section 2 : Gestion des Erreurs Métier - src/Backend/Exception/ **

****

Ce répertoire contient des classes d'exception personnalisées pour une gestion des erreurs plus fine et sémantique que les exceptions PHP génériques. Chaque exception correspond à un cas d'erreur métier spécifique. 1 

● **AuthenticationException.php**: extends \\Exception. Levée pour des erreurs générales d'authentification. 

● **CompteBloqueException.php**: extends AuthenticationException. Levée par AuthenticationService lorsque l'utilisateur tente de se connecter à un compte temporairement bloqué. 1 

● **CompteNonValideException.php**: extends AuthenticationException. Levée si le compte n'est pas encore activé par le RS. 1 

● **DoublonException.php**: extends \\RuntimeException. Levée lorsqu'une contrainte d'unicité de la base de données est violée \(ex: email déjà utilisé\). 

● **ElementNonTrouveException.php**: extends \\RuntimeException. Levée lorsqu'une recherche d'entité par ID ne retourne aucun résultat \(ex: Rapport::find\($id\) est nul \). 

● **EmailException.php**: extends \\Exception. Levée par EmailService en cas d'échec de l'envoi d'un email. 

● **EmailNonValideException.php**: extends AuthenticationException. Levée si l'email n'a pas encore été validé via le token. 1 

● **IdentifiantsInvalidesException.php**: extends AuthenticationException. Levée par AuthenticationService lorsque le couple login/mot de passe est incorrect. 

● **ModeleNonTrouveException.php**: extends ElementNonTrouveException. 

Spécifique à la non-trouvail e d'un modèle de rapport. 

● **MotDePasseInvalideException.php**: extends ValidationException. Levée lors du changement de mot de passe si l'ancien mot de passe est incorrect. 

● **OperationImpossibleException.php**: extends \\LogicException. Levée lorsqu'une action est tentée sur une entité dans un état qui ne le permet pas \(ex: tenter de modifier un rapport déjà soumis\). 

● **PermissionException.php**: extends \\Exception. Levée par HabilitationService ou dans les contrôleurs si un utilisateur tente d'accéder à une ressource sans avoir le droit requis. 1 

● **TokenExpireException.php**: extends AuthenticationException. Levée si le token de réinitialisation de mot de passe ou de validation d'email a expiré. 1 

● **TokenInvalideException.php**: extends AuthenticationException. Levée si le token fourni est invalide ou n'existe pas. 1 

● **UtilisateurNonTrouveException.php**: extends ElementNonTrouveException. 

Spécifique à la non-trouvail e d'un utilisateur. 

● **ValidationException.php**: extends \\Exception. Levée par FormValidator ou les services lorsque les données d'entrée ne respectent pas les règles de validation. 



**Section 3 : Traitements Asynchrones - src/Worker/ **

****

Ce répertoire contient les classes responsables de l'exécution des tâches longues en arrière-plan, via une file d'attente \(queue\), pour ne pas bloquer l'interface utilisateur. 1 



**AbstractJob.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Worker; 



● **Définition de la Classe** 

PHP 

abstract class AbstractJob 



● **Fonctionnalités \(Méthodes\) **

○ abstract public function execute\(\): void; : Méthode abstraite que chaque tâche concrète devra implémenter pour contenir sa logique d'exécution. 



**DataImportJob.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Worker; 



● **Fonctionnalités \(Méthodes\) **

○ public function \_\_construct\(string $filePath, array $mapping, string $userId\) : Le constructeur reçoit le chemin du fichier à importer, les règles de mappage 

et l'ID de l'utilisateur qui a initié l'import. 

○ public function execute\(\): void : Contient la logique lourde de l'importation : lecture du fichier, validation de chaque ligne, insertion transactionnel e dans la base de données, et génération du rapport final. 1 



**EmailSenderJob.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Worker; 



● **Fonctionnalités \(Méthodes\) **

○ public function \_\_construct\(string $to, string $subject, string $body\) : Le constructeur reçoit les paramètres de l'email à envoyer. 

○ public function execute\(\): void : Appel e le EmailService pour envoyer l'email. 

Utile pour les envois en masse. 



**PdfGeneratorJob.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Worker; 



● **Fonctionnalités \(Méthodes\) **

○ public function \_\_construct\(string $entityType, string $entityId, string $template\) : Le constructeur reçoit les informations nécessaires pour générer le PDF \(ex: type "bul etin", ID de l'étudiant, template à utiliser\). 

○ public function execute\(\): void : Appel e le PdfGeneratorService pour créer le fichier PDF et le stocker. Utilisé pour la génération en masse de bul etins ou de PV. 1 



**Section 4 : La Couche de Contrôle - src/Backend/Controller/ **

****

Les contrôleurs font le lien entre les requêtes de l'utilisateur \(définies dans routes/web.php\), les services qui contiennent la logique métier, et les vues qui affichent les informations. 



**BaseController.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Control er; 

use App\\Service\\Habilitation\\HabilitationServiceInterface; 



● **Fonctionnalités \(Méthodes\) **

○ protected function render\(string $view, array $data =\): void : Méthode utilitaire pour inclure un fichier de vue et lui passer des données. 

○ protected function redirect\(string $url\): void : Méthode pour effectuer une redirection HTTP. 

○ protected function checkPermission\(string $traitementId\): void : Raccourci pour appeler HabilitationService et lever une PermissionException si l'utilisateur n'a pas le droit. 

○ protected function getUser\(\):?Utilisateur : Récupère l'utilisateur actuel ement connecté depuis la session. 



**AuthentificationController.php **

****

● **Use Statements** : AuthenticationService, ValidationException, CompteBloqueException, etc. 

● **Fonctionnalités \(Méthodes\) **

○ public function showLogin\(\): Affiche la vue Auth/login.php. 

○ public function handleLogin\(\): Traite les données du formulaire de connexion, appel e AuthenticationService::login\(\), et redirige vers le tableau de bord ou ré-affiche le formulaire avec une erreur. 

○ public function logout\(\): Appel e AuthenticationService::logout\(\) et redirige vers la page de connexion. 

○ public function showForgotPassword\(\): Affiche la vue Auth/forgot\_password\_form.php. 

○ public function handleForgotPassword\(\): Appel e 

AuthenticationService::requestPasswordReset\(\). 

○ public function showResetPassword\(string $token\): Vérifie le token et affiche la vue Auth/reset\_password\_form.php. 

○ public function handleResetPassword\(\): Traite le nouveau mot de passe et appel e AuthenticationService::resetPasswordWithToken\(\). 



**DashboardController.php **

****

● **Fonctionnalités \(Méthodes\) **

○ public function index\(\): Récupère le type de l'utilisateur connecté et le redirige vers le contrôleur de tableau de bord approprié \(ex: /etudiant/dashboard, 

/admin/dashboard\). 



**ProfilController.php **

****

● **Use Statements** : UtilisateurService, ValidationException. 

● **Fonctionnalités \(Méthodes\) **

○ public function show\(\): Affiche la vue common/profil\_utilisateur.php avec les données de l'utilisateur. 

○ public function update\(\): Traite les données du formulaire de mise à jour de profil et appel e UtilisateurService::updateUserProfile\(\). 

○ public function changePassword\(\): Traite le formulaire de changement de mot de passe et appel e UtilisateurService::changePassword\(\). 



**RechercheController.php **

****

● **Use Statements** : RechercheService. 

● **Fonctionnalités \(Méthodes\) **

○ public function search\(\): Récupère la requête et les filtres, appel e 

RechercheService::search\(\) et affiche une vue de résultats. 



**Sous-répertoire Administration/ **

****

● **AdminDashboardController.php**: show\(\) affiche 

Administration/dashboard\_admin.php avec les données des services ReportingService et SupervisionService. 

● **ChecklistConformiteController.php**: list\(\), create\(\), edit\(\), delete\(\) pour gérer les critères de la checklist via ChecklistService et ReferentielService. Affiche les vues de Administration/checklist\_conformite/. 

● **ConfigSystemeController.php**: show\(\) et update\(\) pour gérer les paramètres globaux via ConfigurationService. 

● **DelegationController.php**: list\(\), create\(\), revoke\(\) pour gérer les délégations via DelegationService. Affiche les vues de Administration/delegation/. 

● **HabilitationController.php**: showMatrix\(\), updateMatrix\(\) pour gérer la matrice de permissions \(table rattacher\) via HabilitationService. 

● **ImportationController.php**: showInterface\(\), handleUpload\(\), showPreview\(\), launchImport\(\) pour orchestrer le processus d'importation via ImportationService. 

Affiche les vues de Administration/importation/. 

● **ModeleRapportController.php**: list\(\), create\(\), edit\(\), assign\(\) pour gérer les modèles de rapport via ModeleRapportService. Affiche les vues de Administration/modeles\_rapport/. 

● **NotificationMatrixController.php**: show\(\) et update\(\) pour gérer la matrice de diffusion des notifications via NotificationService. Affiche la vue Administration/notifications\_matrix/interface\_matrice\_diffusion.php. 

● **ReferentialController.php**: Contrôleur générique pour le CRUD des référentiels \(Grades, Fonctions, Niveaux d'étude...\) via ReferentielService. Affiche les vues de Administration/referentiels/. 

● **ReportingController.php**: showDashboard\(\) pour afficher les KPIs stratégiques via ReportingService. Affiche la vue 

Administration/reporting/dashboard\_reporting.php. 

● **SupervisionController.php**: showAuditLogs\(\), showErrorLogs\(\), showQueueStatus\(\) pour la supervision technique via SupervisionService. Affiche les vues de Administration/supervision/. 

● **TransitionController.php**: showInterface\(\), reassignTasks\(\) pour gérer la réassignation des tâches via TransitionService. Affiche la vue Administration/transition/interface\_reassignation\_taches.php. 

● **UtilisateurController.php**: list\(\), show\(\), create\(\), update\(\) pour la gestion complète des utilisateurs via UtilisateurService. Affiche les vues de Administration/utilisateurs/. 



**Sous-répertoires par Rôle **

****

● **Commission/ **

○ **CommissionDashboardController.php**: show\(\) affiche Commission/dashboard\_commission.php avec les sessions et PV en attente. 

○ **SessionValidationController.php**: list\(\), create\(\), show\(\), addReport\(\), start\(\), showVoteInterface\(\), submitVote\(\) pour gérer les sessions via CommissionService. Affiche les vues de Commission/session/. 

○ **PvController.php**: show\(\), edit\(\), delegate\(\), submitForApproval\(\), approve\(\) pour gérer les PV via CommissionService. Affiche les vues de Commission/pv/. 

● **Common/ **

○ **MessagerieController.php**: listConversations\(\), showConversation\(\), sendMessage\(\) via MessagerieService. Affiche la vue common/chat.php. 

○ **NotificationController.php**: list\(\) pour afficher les notifications de l'utilisateur via NotificationService. Affiche la vue common/notifications.php. 

● **Etudiant/ **

○ **EtudiantDashboardController.php**: show\(\) affiche 

Etudiant/dashboard\_etudiant.php avec le statut du rapport et les notifications. 

○ **RapportController.php**: showEditor\(\), saveSection\(\), submit\(\) pour gérer la rédaction et soumission du rapport via RapportService. Affiche les vues de Etudiant/rapport/. 

○ **ReclamationController.php**: list\(\), create\(\) pour gérer les réclamations via ReclamationService. Affiche les vues de Etudiant/reclamation/. 

● **PersonnelAdministratif/ **

○ **PersonnelDashboardController.php**: show\(\) affiche PersonnelAdministratif/dashboard\_personnel.php. 

○ **ConformiteController.php**: listToVerify\(\), showVerificationInterface\(\), processVerification\(\) pour la vérification de conformité via ConformiteService. 

Affiche les vues de PersonnelAdministratif/conformite/. 

○ **ScolariteController.php**: showActivationInterface\(\), activateAccounts\(\), showPenaltyManagement\(\), updatePenalty\(\), showGradeEntry\(\) pour les tâches du RS via ScolariteService. Affiche les vues de 

PersonnelAdministratif/scolarite/. 

**Sources des citations **

1. Système d'information.docx 

**Plan d'Implémentation Exhaustif des Couches Service et Util** **Introduction : Orchestration de la Logique Métier **

Ce document technique détail e la conception de la couche Service et du répertoire Util, qui constituent le cœur de la logique métier et des fonctionnalités transversales de l'application "GestionMySoutenance". Chaque service est conçu pour être une brique fonctionnel e autonome, encapsulant une responsabilité métier spécifique et orchestrant les interactions avec la couche Model. Les utilitaires, quant à eux, fournissent des fonctionnalités techniques réutilisables à travers toute l'application. 



**Section 1 : Plan d'Implémentation de la Couche Service **

****

La couche Service est organisée par domaine fonctionnel. Chaque service expose ses fonctionnalités via une interface \(...ServiceInterface.php\), garantissant un couplage faible et une meil eure testabilité. 



**Service/Audit/ **

****

Ce service centralise toutes les opérations de journalisation et de traçabilité des actions critiques. 1 



**AuditService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Audit; 



use App\\Backend\\Model\\Utilisateur; 

use App\\Backend\\Model\\Enregistrer; 

use App\\Backend\\Model\\Action; 

use DateTime; 



● **Fonctionnalités \(Méthodes\) **

○ public function logAction\(Utilisateur $utilisateur, string $idAction,?string $idEntiteConcernee = nul ,?string $typeEntiteConcernee = nul ,?array $details 

= nul ,?string $adresseIp = nul ,?string $userAgent = nul \): void : Enregistre une action critique dans la table enregistrer. 

○ public function getHistoriquePourEntite\(string $idEntite, string $typeEntite\): array : Récupère l'historique complet des actions pour une entité donnée \(ex: un rapport\). 

○ public function getActiviteUtilisateur\(Utilisateur $utilisateur, DateTime $debut, DateTime $fin\): array : Récupère les actions d'un utilisateur sur une période donnée. 



**Service/Authentification/ **

****

Ce service gère l'ensemble du cycle de vie de l'authentification et de la sécurité des comptes. 1 



**AuthenticationService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Authentification; 



use App\\Backend\\Model\\Utilisateur; 

use App\\Backend\\Model\\HistoriqueMotDePasse; 

use App\\Backend\\Service\\Email\\EmailServiceInterface; 

use App\\Backend\\Exception\\IdentifiantsInvalidesException; 

use App\\Backend\\Exception\\CompteBloqueException; 

use RobThree\\Auth\\TwoFactorAuth; 

use DateTime; 



● **Fonctionnalités \(Méthodes\) **

○ public function login\(string $login, string $password\): Utilisateur : Tente de 

connecter un utilisateur et gère les échecs. 

○ public function logout\(\): void : Déconnecte l'utilisateur et détruit la session. 

○ public function requestPasswordReset\(string $email\): void : Génère un token de réinitialisation et envoie l'email. 

○ public function resetPasswordWithToken\(string $token, string $newPassword\): bool : Réinitialise le mot de passe à partir d'un token valide. 

○ public function enable2FA\(Utilisateur $utilisateur\): string : Génère un secret 2FA et retourne le QR code. 

○ public function verify2FACode\(Utilisateur $utilisateur, string $code\): bool : Vérifie un code 2FA soumis. 

○ public function handleFailedLoginAttempt\(Utilisateur $utilisateur\): void : Incrémente le compteur d'échecs et bloque le compte si nécessaire. 

○ public function sendValidationEmail\(Utilisateur $utilisateur\): void : Envoie l'email de validation de compte. 

○ public function validateEmailWithToken\(string $token\): bool : Valide une adresse email à partir d'un token. 



**Service/Cache/ **

****

Service générique pour la gestion de la mise en cache des données afin d'optimiser les performances. 1 



**CacheService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Cache; 

// Potentiel ement des use vers une librairie comme Redis ou Memcached 



● **Fonctionnalités \(Méthodes\) **

○ public function get\(string $key\): mixed : Récupère une donnée depuis le cache. 

○ public function set\(string $key, mixed $data, int $ttl\): bool : Stocke une donnée dans le cache avec une durée de vie. 

○ public function delete\(string $key\): bool : Supprime une donnée du cache. 

○ public function clear\(\): bool : Vide l'intégralité du cache. 



**Service/Checklist/ **

****

Gère la logique métier de la checklist de conformité des rapports. 1 



**ChecklistService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Checklist; 



use App\\Backend\\Model\\CritereConformiteRef; 

use App\\Backend\\Model\\ConformiteRapportDetails; 

use App\\Backend\\Model\\RapportEtudiant; 

use App\\Backend\\Model\\PersonnelAdministratif; 



● **Fonctionnalités \(Méthodes\) **

○ public function getActiveChecklist\(\): array : Récupère la liste des critères de conformité actifs. 

○ public function saveChecklistResults\(RapportEtudiant $rapport, PersonnelAdministratif $agent, array $results\): void : Enregistre les résultats de la vérification de la checklist pour un rapport. 

○ public function getChecklistResultsForReport\(RapportEtudiant $rapport\): array : Récupère les résultats de la checklist pour un rapport donné. 



**Service/Commission/ **

****

Encapsule toute la logique complexe du module de la commission de validation. 1 



**CommissionService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Commission; 



use App\\Backend\\Model\\SessionValidation; 

use App\\Backend\\Model\\RapportEtudiant; 

use App\\Backend\\Model\\Enseignant; 

use App\\Backend\\Model\\VoteCommission; 

use App\\Backend\\Model\\CompteRendu; 

use App\\Backend\\Model\\ValidationPv; 

use App\\Backend\\Service\\Notification\\NotificationServiceInterface; use App\\Backend\\Service\\Pdf\\PdfGeneratorServiceInterface; 



● **Fonctionnalités \(Méthodes\) **

○ public function createSession\(string $nom, Enseignant $president, array $rapportIds,?DateTime $dateFinPrevue\): SessionValidation : Crée une nouvel e session de validation. 

○ public function startSession\(SessionValidation $session\): void : Démarre une session, la verrouil e et notifie les membres. 

○ public function closeSession\(SessionValidation $session\): bool : Clôture une session si tous les rapports sont statués. 

○ public function submitVote\(RapportEtudiant $rapport, Enseignant $votant, string $decisionId,?string $commentaire, int $tour\): VoteCommission : Enregistre un vote et déclenche la vérification du consensus. 

○ public function startNewVotingRound\(RapportEtudiant $rapport\): void : Lance un nouveau tour de vote en cas de désaccord. 

○ public function takeOwnershipOfPvDraft\(SessionValidation $session, Enseignant $redacteur\): CompteRendu : Prend en charge la rédaction d'un PV 

et le verrouil e. 

○ public function delegatePvDraft\(CompteRendu $pv, Enseignant $nouveauRedacteur\): void : Délègue la rédaction du PV à un autre membre. 

○ public function submitPvForApproval\(CompteRendu $pv\): void : Soumet un projet de PV à la validation col égiale. 

○ public function approvePv\(CompteRendu $pv, Enseignant $approbateur\): void 

: Enregistre l'approbation d'un PV et vérifie le consensus. 

○ public function finalizeAndDistributePv\(CompteRendu $pv\): void : Finalise un PV, génère le PDF et le distribue. 



**Service/Configuration/ **

****

Permet de gérer les paramètres globaux de l'application. 1 



**ConfigurationService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Configuration; 

// Potentiel ement un modèlèConfigurationòu lecture d'un fichier.env 



● **Fonctionnalités \(Méthodes\) **

○ public function get\(string $key, mixed $default = nul \): mixed : Récupère la valeur d'un paramètre de configuration. 

○ public function set\(string $key, mixed $value\): void : Modifie la valeur d'un paramètre de configuration \(droit admin requis\). 



**Service/Conformite/ **

****

Gère le workflow de la vérification de conformité administrative. 1 



**ConformiteService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Conformite; 



use App\\Backend\\Model\\RapportEtudiant; 

use App\\Backend\\Model\\PersonnelAdministratif; 

use App\\Backend\\Model\\Approuver; 

use App\\Backend\\Service\\Audit\\AuditServiceInterface; 

use App\\Backend\\Service\\Notification\\NotificationServiceInterface; 



● **Fonctionnalités \(Méthodes\) **

○ public function getReportsToVerify\(\): array : Récupère la liste des rapports en attente de vérification. 

○ public function processConformityCheck\(RapportEtudiant $rapport, PersonnelAdministratif $agent, string $statutConformiteId,?string $commentaire\): void : Traite le résultat de la vérification, met à jour le statut du rapport et notifie l'étudiant si nécessaire. 



**Service/Delegation/ **

****

Gère la création et le cycle de vie des délégations de permissions. 1 



**DelegationService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Delegation; 



use App\\Backend\\Model\\Utilisateur; 

use App\\Backend\\Model\\Traitement; 

use App\\Backend\\Model\\Delegation; 

use DateTime; 



● **Fonctionnalités \(Méthodes\) **

○ public function createDelegation\(Utilisateur $delegant, Utilisateur $delegue, string $traitementId, DateTime $dateDebut, DateTime $dateFin\): Delegation : Crée une nouvel e délégation. 

○ public function revokeDelegation\(Delegation $delegation\): void : Révoque une 

délégation active avant sa date de fin. 

○ public function getActiveDelegationsForUser\(Utilisateur $utilisateur\): array : Récupère toutes les délégations actives pour un utilisateur \(en tant que délégué\). 



**Service/Email/ **

****

Service d'abstraction pour l'envoi d'emails, utilisant une librairie comme PHPMailer. 1 



**EmailService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Email; 



use PHPMailer\\PHPMailer\\PHPMailer; 

use PHPMailer\\PHPMailer\\Exception; 



● **Fonctionnalités \(Méthodes\) **

○ public function send\(string $toAddress, string $toName, string $subject, string $htmlBody,?string $altBody = ' \): bool : Envoie un email. 

○ public function sendFromTemplate\(string $templateName, string $toAddress, string $toName, string $subject, array $data\): bool : Construit un email à partir d'un template et l'envoie. 



**Service/Habilitation/ **

****

Service central du système RBAC, responsable de la vérification des permissions. 1 



**HabilitationService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Habilitation; 



use App\\Backend\\Model\\Utilisateur; 

use App\\Backend\\Model\\Rattacher; 

use App\\Backend\\Model\\Delegation; 

use App\\Backend\\Service\\Cache\\CacheServiceInterface; 



● **Fonctionnalités \(Méthodes\) **

○ public function hasPermission\(Utilisateur $utilisateur, string $traitementId\): bool : Vérifie si un utilisateur a une permission spécifique \(via son groupe et ses délégations actives\). 

○ public function getPermissionsForUser\(Utilisateur $utilisateur\): array : Récupère la liste complète des permissions d'un utilisateur. 

○ public function updateUserPermissionsInSession\(Utilisateur $utilisateur\): void 

: Met à jour les permissions dans la session d'un utilisateur \(utilisé après un changement de droits par un admin\). 



**Service/Identifiant/ **

****

Génère des identifiants uniques, lisibles et annuels de manière sécurisée. 1 



**IdentifiantGenerator.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Identifiant; 



use App\\Backend\\Model\\Sequences; 

use PDO; 



● **Fonctionnalités \(Méthodes\) **

○ public function generer\(string $prefixe\): string : Génère un nouvel identifiant unique pour un préfixe donné, en utilisant une transaction et un verrou de ligne. 



**Service/Importation/ **

****

Gère le processus avancé d'importation de données en plusieurs étapes. 1 



**ImportationService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Importation; 



use App\\Backend\\Service\\Queue\\QueueServiceInterface; 

use App\\Worker\\DataImportJob; 

use PhpOffice\\PhpSpreadsheet\\Reader\\Xlsx; 



● **Fonctionnalités \(Méthodes\) **

○ public function startImportProcess\(string $filePath, string $entityType, array $mapping, Utilisateur $initiateur\): string : Lance le processus d'importation en plaçant une tâche dans la file d'attente. 

○ public function getImportStatus\(string $jobId\): array : Récupère le statut d'une tâche d'importation. 

○ public function getImportReport\(string $jobId\): array : Récupère le rapport final d'une tâche d'importation terminée. 



**Service/Messagerie/ **

****

Encapsule la logique du système de messagerie interne. 1 



**MessagerieService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Messagerie; 



use App\\Backend\\Model\\Utilisateur; 

use App\\Backend\\Model\\Conversation; 

use App\\Backend\\Model\\MessageChat; 

use App\\Backend\\Model\\ParticipantConversation; 



● **Fonctionnalités \(Méthodes\) **

○ public function createConversation\(Utilisateur $initiateur, array $participants,?string $nom = nul \): Conversation : Crée une nouvel e conversation. 

○ public function sendMessage\(Utilisateur $expediteur, Conversation $conversation, string $contenu\): MessageChat : Envoie un message dans une conversation. 

○ public function getConversationsForUser\(Utilisateur $utilisateur\): array : Récupère les conversations d'un utilisateur. 

○ public function getMessagesForConversation\(Conversation $conversation\): array : Récupère les messages d'une conversation. 

○ public function markMessageAsRead\(MessageChat $message, Utilisateur $utilisateur\): void : Marque un message comme lu pour un utilisateur. 



**Service/Modele/ **

****

Gère la création et l'assignation des modèles de rapport. 1 



**ModeleRapportService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Modele; 



use App\\Backend\\Model\\RapportModele; 

use App\\Backend\\Model\\RapportModeleSection; 

use App\\Backend\\Model\\RapportModeleAssignation; 

use App\\Backend\\Model\\NiveauEtude; 



● **Fonctionnalités \(Méthodes\) **

○ public function createModele\(string $nom, string $version,?string $description\): RapportModele : Crée un nouveau modèle de rapport. 

○ public function addSectionToModele\(RapportModele $modele, string $titre, int $ordre,?string $contenuParDefaut\): RapportModeleSection : Ajoute une section à un modèle. 

○ public function assignModeleToNiveau\(RapportModele $modele, NiveauEtude $niveau\): void : Assigne un modèle à un niveau d'étude. 



**Service/Notification/ **

****

Orchestre l'envoi de notifications en fonction de la matrice de diffusion. 1 



**NotificationService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Notification; 



use App\\Backend\\Model\\MatriceNotificationRegles; 

use App\\Backend\\Model\\Utilisateur; 

use App\\Backend\\Service\\Email\\EmailServiceInterface; 



● **Fonctionnalités \(Méthodes\) **

○ public function triggerNotification\(string $actionId, array $contextData\): void : Déclenche les notifications pour un événement métier donné, en consultant la 

matrice. 

○ public function getUserNotifications\(Utilisateur $utilisateur\): array : Récupère les notifications internes d'un utilisateur. 

○ public function markNotificationAsRead\(string $receptionId, Utilisateur $utilisateur\): void : Marque une notification comme lue. 



**Service/Pdf/ **

****

Service technique pour la génération de documents PDF à partir de templates HTML. 1 



**PdfGeneratorService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Pdf; 



use TCPDF; 



● **Fonctionnalités \(Méthodes\) **

○ public function generateFromHtml\(string $htmlContent\): string : Convertit une chaîne HTML en PDF et retourne le contenu binaire. 

○ public function generateFromTemplate\(string $templatePath, array $data\): string : Charge un template HTML, y injecte des données, et le convertit en PDF. 



**Service/Queue/ **

****

Service d'abstraction pour la gestion d'une file d'attente de tâches asynchrones. 1 



**QueueService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Queue; 



use App\\Worker\\AbstractJob; 

// Potentiel ement des use vers une librairie comme RabbitMQ, Beanstalkd, ou une implémentation DB. 



● **Fonctionnalités \(Méthodes\) **

○ public function dispatch\(AbstractJob $job\): string : Ajoute une nouvel e tâche à la file d'attente et retourne son ID. 

○ public function getJobStatus\(string $jobId\): string : Récupère le statut d'une tâche \(en attente, en cours, terminée, échouée\). 



**Service/Rapport/ **

****

Gère le cycle de vie et la logique métier d'un rapport étudiant. 1 



**RapportService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Rapport; 



use App\\Backend\\Model\\RapportEtudiant; 

use App\\Backend\\Model\\Etudiant; 

use App\\Backend\\Model\\SectionRapport; 

use App\\Backend\\Service\\Audit\\AuditServiceInterface; 



● **Fonctionnalités \(Méthodes\) **

○ public function createRapport\(Etudiant $etudiant, array $metadata,?RapportModele $modele = nul \): RapportEtudiant : Crée un nouveau rapport en brouil on. 

○ public function updateSection\(SectionRapport $section, string $contenu\): void : Met à jour le contenu d'une section de rapport. 

○ public function submitRapport\(RapportEtudiant $rapport\): void : Soumet formel ement un rapport, le verrouil e et notifie l'administration. 

○ public function returnRapportForCorrection\(RapportEtudiant $rapport, string $commentaire\): void : Retourne un rapport à l'étudiant pour correction. 

○ public function resubmitCorrectedRapport\(RapportEtudiant $rapport, string $noteExplicative\): void : Resoumet un rapport corrigé, en enregistrant la note explicative. 



**Service/Reclamation/ **

****

Gère le processus de soumission et de traitement des réclamations. 1 



**ReclamationService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Reclamation; 



use App\\Backend\\Model\\Reclamation; 

use App\\Backend\\Model\\Etudiant; 

use App\\Backend\\Model\\PersonnelAdministratif; 



● **Fonctionnalités \(Méthodes\) **

○ public function createReclamation\(Etudiant $etudiant, string $sujet, string $description\): Reclamation : Crée une nouvel e réclamation. 

○ public function assignReclamation\(Reclamation $reclamation, PersonnelAdministratif $agent\): void : Assigne une réclamation à un agent pour traitement. 

○ public function respondToReclamation\(Reclamation $reclamation, string $reponse\): void : Apporte une réponse à une réclamation et la clôture. 



**Service/Referentiel/ **

****

Service générique pour la gestion \(CRUD\) des tables de référentiels. 1 



**ReferentielService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Referentiel; 



use App\\Backend\\Model\\BaseModel; 



● **Fonctionnalités \(Méthodes\) **

○ public function getAl \(string $modelClass\): array : Récupère toutes les entrées d'un référentiel. 

○ public function create\(string $modelClass, array $data\): BaseModel : Crée une nouvel e entrée dans un référentiel. 

○ public function update\(BaseModel $entry, array $data\): bool : Met à jour une entrée de référentiel. 

○ public function delete\(BaseModel $entry\): bool : Supprime une entrée de référentiel. 



**Service/Reporting/ **

****

Fournit les données agrégées pour les tableaux de bord de pilotage. 1 



**ReportingService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Reporting; 



use PDO; 



● **Fonctionnalités \(Méthodes\) **

○ public function getOperationalDashboardData\(\): array : Calcule et retourne les KPIs pour le tableau de bord opérationnel. 

○ public function getStrategicDashboardData\(int $annee\): array : Calcule et retourne les KPIs pour le tableau de bord stratégique pour une année donnée. 



**Service/Recherche/ **

****

Implémente la logique de recherche globale avancée. 1 



**RechercheService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Recherche; 

// Potentiel ement un moteur de recherche comme Elasticsearch ou une recherche Ful -Text SQL 



● **Fonctionnalités \(Méthodes\) **

○ public function search\(string $query, array $filters =, int $page = 1, int $limit = 

20\): array : Exécute une recherche multicritères et paginée sur plusieurs entités. 



**Service/Scolarite/ **

****

Gère les tâches administratives spécifiques au service de la scolarité. 1 



**ScolariteService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Scolarite; 



use App\\Backend\\Model\\Etudiant; 

use App\\Backend\\Model\\Inscrire; 

use App\\Backend\\Model\\Penalite; 

use App\\Backend\\Model\\Evaluer; 

use App\\Backend\\Service\\Utilisateur\\UtilisateurServiceInterface; use App\\Backend\\Service\\Pdf\\PdfGeneratorServiceInterface; 



● **Fonctionnalités \(Méthodes\) **

○ public function activateStudentAccount\(Etudiant $etudiant\): void : Active le compte d'un étudiant après vérification des prérequis. 

○ public function processPenalty\(Penalite $penalite, string $newStatusId\): void : Met à jour le statut d'une pénalité \(ex: la marquer comme réglée\). 

○ public function recordGrades\(Etudiant $etudiant, array $gradesData\): void : Enregistre les notes d'un étudiant pour plusieurs matières. 

○ public function generateTranscript\(Etudiant $etudiant, string $anneeAcademiqueId\): string : Génère le bul etin de notes officiel en PDF 

pour un étudiant. 

○ public function detectAndApplyPenalties\(\): void : Tâche planifiée \(CRON\) pour détecter les retards et créer les pénalités. 



**Service/Supervision/ **

****

Fournit les données pour les outils de supervision technique. 1 



**SupervisionService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Supervision; 



use App\\Backend\\Service\\Audit\\AuditServiceInterface; 



● **Fonctionnalités \(Méthodes\) **

○ public function getAuditLogs\(array $filters\): array : Récupère les journaux d'audit avec des filtres. 

○ public function getErrorLogs\(int $limit = 100\): array : Récupère les derniers journaux d'erreurs applicatives. 

○ public function getQueueStatus\(\): array : Récupère l'état de la file d'attente des tâches asynchrones. 



**Service/Transition/ **

****

Gère la réassignation des tâches lors d'un changement de rôle ou d'un départ. 1 



**TransitionService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Transition; 



use App\\Backend\\Model\\Utilisateur; 



● **Fonctionnalités \(Méthodes\) **

○ public function findOrphanTasks\(Utilisateur $departingUser\): array : Identifie toutes les tâches en attente assignées à un utilisateur partant. 

○ public function reassignTask\(string $taskType, string $taskId, Utilisateur $newUser\): bool : Réassigne une tâche orpheline à un nouvel utilisateur. 



**Service/Utilisateur/ **

****

Gère la logique métier liée aux profils utilisateurs. 1 



**UtilisateurService.php **

****

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Service\\Utilisateur; 



use App\\Backend\\Model\\Utilisateur; 

use App\\Backend\\Model\\Etudiant; 

use App\\Backend\\Model\\Enseignant; 

use App\\Backend\\Model\\PersonnelAdministratif; 



● **Fonctionnalités \(Méthodes\) **

○ public function createUserAndProfile\(array $userData, array $profileData, string $userType\): Utilisateur : Crée un compte utilisateur et son profil métier associé \(étudiant, enseignant...\). 

○ public function updateUserProfile\(Utilisateur $utilisateur, array $profileData\): bool : Met à jour les informations du profil métier d'un utilisateur. 

○ public function changePassword\(Utilisateur $utilisateur, string $oldPassword, string $newPassword\): bool : Permet à un utilisateur de changer son propre mot de passe. 

○ public function adminResetPassword\(Utilisateur $utilisateur\): string : Permet à un admin de réinitialiser le mot de passe d'un utilisateur et retourne le nouveau mot de passe temporaire. 



**Section 2 : Plan d'Implémentation des Utilitaires **

****

Le répertoire Util contient des classes techniques transversales qui n'encapsulent pas de logique métier directe mais fournissent des outils essentiels au bon fonctionnement de l'application. 



**Util/DatabaseSessionHandler.php **

****

Implémente la gestion des sessions PHP en base de données pour permettre la mise à jour des droits en temps réel. 1 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Util; 



use SessionHandlerInterface; 

use PDO; 



● **Fonctionnalités \(Méthodes\) **

○ public function open\(string $path, string $name\): bool : Ouvre la session. 

○ public function close\(\): bool : Ferme la session. 

○ public function read\(string $id\): string|false : Lit les données de session depuis la table sessions. 

○ public function write\(string $id, string $data\): bool : Écrit les données de session dans la table sessions. 

○ public function destroy\(string $id\): bool : Détruit une session de la base de données. 

○ public function gc\(int $max\_lifetime\): int|false : Exécute le "garbage col ector" 

pour nettoyer les vieil es sessions. 



**Util/FormValidator.php **

****

Fournit des méthodes pour valider les données soumises via des formulaires. 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Util; 



● **Fonctionnalités \(Méthodes\) **

○ public function \_\_construct\(array $data, array $rules\) : Initialise le validateur avec les données et les règles. 

○ public function validate\(\): bool : Exécute la validation. 

○ public function getErrors\(\): array : Retourne un tableau des erreurs de 

validation. 

○ protected function ruleRequired\(string $field\): bool : Règle de validation pour les champs requis. 

○ protected function ruleEmail\(string $field\): bool : Règle de validation pour le format email. 

○ protected function ruleMinLength\(string $field, int $length\): bool : Règle de validation pour la longueur minimale. 



**Util/Sanitizer.php **

****

Fournit des méthodes pour nettoyer les entrées utilisateur afin de prévenir les fail es de sécurité \(XSS\). 

● **Namespace et Use Statements** 

PHP 

namespace App\\Backend\\Util; 



● **Fonctionnalités \(Méthodes\) **

○ public static function sanitizeString\(string $input\): string : Nettoie une chaîne de caractères simple \(supprime les balises HTML\). 

○ public static function sanitizeEmail\(string $input\): string : Valide et nettoie une adresse email. 

○ public static function sanitizeUrl\(string $input\): string : Valide et nettoie une URL. 

**Sources des citations **

1. Système d'information.docx 


# Document Outline

+ Système d'information 
+ Développement de modèles PHP \_ Plan\_  
	+ Plan d'Implémentation Exhaustif de la Couche Modèle   
		+ Introduction : Un Blueprint pour l'Implémentation  
		+ Table 1: Cartographie Modèle-Table et Responsabilités Fondamentales  
		+ Section 1: La Fondation - BaseModel.php   
			+ BaseModel.php  

		+ Section 2: Plan d'Implémentation Alphabétique des Modèles \(A-Z\)   
			+ Acquerir.php  
			+ Action.php  
			+ Affecter.php  
			+ AnneeAcademique.php  
			+ Approuver.php  
			+ Attribuer.php  
			+ CompteRendu.php  
			+ ConformiteRapportDetails.php  
			+ Conversation.php  
			+ CritereConformiteRef.php  
			+ DecisionPassageRef.php  
			+ DecisionValidationPvRef.php  
			+ DecisionVoteRef.php  
			+ Delegation.php  
			+ DocumentGenere.php  
			+ Ecue.php  
			+ Enregistrer.php  
			+ Enseignant.php  
			+ Entreprise.php  
			+ Etudiant.php  
			+ Evaluer.php  
			+ FaireStage.php  
			+ Fonction.php  
			+ Grade.php  
			+ GroupeUtilisateur.php  
			+ HistoriqueMotDePasse.php  
			+ Inscrire.php  
			+ LectureMessage.php  
			+ MatriceNotificationRegles.php  
			+ MessageChat.php  
			+ NiveauAccesDonne.php  
			+ NiveauEtude.php  
			+ Notification.php  
			+ Occuper.php  
			+ ParticipantConversation.php  
			+ Penalite.php  
			+ PersonnelAdministratif.php  
			+ Pister.php  
			+ PvSessionRapport.php  
			+ RapportEtudiant.php  
			+ RapportModele.php  
			+ RapportModeleAssignation.php  
			+ RapportModeleSection.php  
			+ Rattacher.php  
			+ Recevoir.php  
			+ Reclamation.php  
			+ Rendre.php  
			+ SectionRapport.php  
			+ Sequences.php  
			+ SessionRapport.php  
			+ Sessions.php  
			+ SessionValidation.php  
			+ Specialite.php  
			+ StatutConformiteRef.php  
			+ StatutJury.php  
			+ StatutPaiementRef.php  
			+ StatutPenaliteRef.php  
			+ StatutPvRef.php  
			+ StatutRapportRef.php  
			+ StatutReclamationRef.php  
			+ Traitement.php  
			+ TypeDocumentRef.php  
			+ TypeUtilisateur.php  
			+ Ue.php  
			+ Utilisateur.php  
			+ ValidationPv.php  
			+ VoteCommission.php   
				+ Sources des citations  




+ Plan de recherche exhaustif\_  
	+ Rapport de Spécification Technique Finale et Conception d'Outils de Développement   
		+ Partie I : Finalisation du Blueprint d'Infrastructure Applicative   
			+ Section 1 : Configuration de l'Environnement et Cycle de Vie de la Requête   
				+ 1.1. Spécification du Fichier d'Environnement .env  
				+ 1.2. Point d'Entrée Public et Séquence d'Amorçage \(Public/index.php\)  
				+ 1.3. Configuration du Serveur Web \(.htaccess\)  

			+ Section 2 : Architecture et Implémentation du Routage Stratégique \(routes/web.php\)   
				+ 2.1. Principes Directeurs du Routage  
				+ 2.2. Intégration du Contrôle d'Accès au Niveau du Routage  
				+ 2.3. Table de Routage Complète  


		+ Partie II : Conception d'un Algorithme de Génération de Code Assistée par IA   
			+ Section 3 : Analyse Stratégique et Identification des Cibles de Génération   
				+ 3.1. Justification Stratégique  
				+ 3.2. Cible de Génération : Le "Stack" CRUD Complet  

			+ Section 4 : Conception de l'Algorithme de Prompt et du Workflow de Génération   
				+ 4.1. Workflow de Génération en Plusieurs Étapes  
				+ 4.2. Catalogue de Prompts Intelligents \(Prompt Chaining\)  



	+ TÂCHE  
	+ SQL  
	+ CONTEXTE  
	+ TÂCHE   
		+ Sources des citations  


+ Plan d'Implémentation \_ Controller, Exception, Worker et Config  
	+ Plan d'Implémentation Exhaustif : Controller, Exception, Worker et Config   
		+ Introduction : Finalisation de l'Architecture Applicative  
		+ Section 1 : Le Cœur de l'Application - src/Config/   
			+ Database.php  
			+ Container.php  

		+ Section 2 : Gestion des Erreurs Métier - src/Backend/Exception/  
		+ Section 3 : Traitements Asynchrones - src/Worker/   
			+ AbstractJob.php  
			+ DataImportJob.php  
			+ EmailSenderJob.php  
			+ PdfGeneratorJob.php  

		+ Section 4 : La Couche de Contrôle - src/Backend/Controller/   
			+ BaseController.php  
			+ AuthentificationController.php  
			+ DashboardController.php  
			+ ProfilController.php  
			+ RechercheController.php  
			+ Sous-répertoire Administration/  
			+ Sous-répertoires par Rôle   
				+ Sources des citations  




+ Plan d'Implémentation des Couches Service et Util  
	+ Plan d'Implémentation Exhaustif des Couches Service et Util   
		+ Introduction : Orchestration de la Logique Métier  
		+ Section 1 : Plan d'Implémentation de la Couche Service   
			+ Service/Audit/   
				+ AuditService.php  

			+ Service/Authentification/   
				+ AuthenticationService.php  

			+ Service/Cache/   
				+ CacheService.php  

			+ Service/Checklist/   
				+ ChecklistService.php  

			+ Service/Commission/   
				+ CommissionService.php  

			+ Service/Configuration/   
				+ ConfigurationService.php  

			+ Service/Conformite/   
				+ ConformiteService.php  

			+ Service/Delegation/   
				+ DelegationService.php  

			+ Service/Email/   
				+ EmailService.php  

			+ Service/Habilitation/   
				+ HabilitationService.php  

			+ Service/Identifiant/   
				+ IdentifiantGenerator.php  

			+ Service/Importation/   
				+ ImportationService.php  

			+ Service/Messagerie/   
				+ MessagerieService.php  

			+ Service/Modele/   
				+ ModeleRapportService.php  

			+ Service/Notification/   
				+ NotificationService.php  

			+ Service/Pdf/   
				+ PdfGeneratorService.php  

			+ Service/Queue/   
				+ QueueService.php  

			+ Service/Rapport/   
				+ RapportService.php  

			+ Service/Reclamation/   
				+ ReclamationService.php  

			+ Service/Referentiel/   
				+ ReferentielService.php  

			+ Service/Reporting/   
				+ ReportingService.php  

			+ Service/Recherche/   
				+ RechercheService.php  

			+ Service/Scolarite/   
				+ ScolariteService.php  

			+ Service/Supervision/   
				+ SupervisionService.php  

			+ Service/Transition/   
				+ TransitionService.php  

			+ Service/Utilisateur/   
				+ UtilisateurService.php  


		+ Section 2 : Plan d'Implémentation des Utilitaires   
			+ Util/DatabaseSessionHandler.php  
			+ Util/FormValidator.php  
			+ Util/Sanitizer.php   
				+ Sources des citations



